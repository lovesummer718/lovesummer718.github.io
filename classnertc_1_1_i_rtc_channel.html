<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NERtc Windows SDK: nertc::IRtcChannel类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NERtc Windows SDK
   &#160;<span id="projectnumber">V5.5.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenertc.html">nertc</a></li><li class="navelem"><a class="el" href="classnertc_1_1_i_rtc_channel.html">IRtcChannel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="classnertc_1_1_i_rtc_channel-members.html">所有成员列表</a>  </div>
  <div class="headertitle">
<div class="title">nertc::IRtcChannel类 参考<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="nertc__channel_8h_source.html">nertc_channel.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:ad809d26d54f150df8dad8a4e51b8d79a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#ad809d26d54f150df8dad8a4e51b8d79a">release</a> ()=0</td></tr>
<tr class="separator:ad809d26d54f150df8dad8a4e51b8d79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd043b3741351b89cfb1b8635ce6248"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#aacd043b3741351b89cfb1b8635ce6248">getChannelName</a> ()=0</td></tr>
<tr class="separator:aacd043b3741351b89cfb1b8635ce6248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f0853ba865a0d0568d0223b8a01b84"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a07f0853ba865a0d0568d0223b8a01b84">setChannelEventHandler</a> (<a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html">IRtcChannelEventHandler</a> *handler)=0</td></tr>
<tr class="separator:a07f0853ba865a0d0568d0223b8a01b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf03b65de2e90983c4d0fdf558bcc5aa"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#acf03b65de2e90983c4d0fdf558bcc5aa">joinChannel</a> (const char *token)=0</td></tr>
<tr class="separator:acf03b65de2e90983c4d0fdf558bcc5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ccb938e986896d1edbaa7eac5504bc"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#ae5ccb938e986896d1edbaa7eac5504bc">joinChannel</a> (const char *token, <a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> uid)=0</td></tr>
<tr class="separator:ae5ccb938e986896d1edbaa7eac5504bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4a1343dd890e58d4ecea3504f7a6a2"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a7b4a1343dd890e58d4ecea3504f7a6a2">joinChannel</a> (const char *token, <a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> uid, <a class="el" href="structnertc_1_1_n_e_rtc_join_channel_options.html">NERtcJoinChannelOptions</a> channel_options)=0</td></tr>
<tr class="separator:a7b4a1343dd890e58d4ecea3504f7a6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83171f8a9d2a9f7408fd37c5d64293f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#ac83171f8a9d2a9f7408fd37c5d64293f">leaveChannel</a> ()=0</td></tr>
<tr class="separator:ac83171f8a9d2a9f7408fd37c5d64293f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5929999546232013f09cead668a85223"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a5929999546232013f09cead668a85223">setStatsObserver</a> (<a class="el" href="classnertc_1_1_i_rtc_media_stats_observer.html">IRtcMediaStatsObserver</a> *observer)=0</td></tr>
<tr class="separator:a5929999546232013f09cead668a85223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac746f2cd380bbfeee1a0d56957a387aa"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#ac746f2cd380bbfeee1a0d56957a387aa">enableLocalAudio</a> (bool enabled)=0</td></tr>
<tr class="separator:ac746f2cd380bbfeee1a0d56957a387aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa535557adb2f412ce32e6709b41d38"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#abfa535557adb2f412ce32e6709b41d38">enableLocalSubStreamAudio</a> (bool enabled)=0</td></tr>
<tr class="separator:abfa535557adb2f412ce32e6709b41d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d276b222652330d9c88ec6d2f276ea9"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a5d276b222652330d9c88ec6d2f276ea9">muteLocalAudioStream</a> (bool mute)=0</td></tr>
<tr class="separator:a5d276b222652330d9c88ec6d2f276ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff5640cea90d89b00d2403d5c09c45d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a7ff5640cea90d89b00d2403d5c09c45d">muteLocalSubStreamAudio</a> (bool mute)=0</td></tr>
<tr class="separator:a7ff5640cea90d89b00d2403d5c09c45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1054b2bb49c402013b62faf170bd2c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#aba1054b2bb49c402013b62faf170bd2c">enableLocalVideo</a> (bool enabled)=0</td></tr>
<tr class="separator:aba1054b2bb49c402013b62faf170bd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c336b19e3c9b0db9a73b9515d7108d7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a5c336b19e3c9b0db9a73b9515d7108d7">enableLocalVideo</a> (<a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a> type, bool enabled)=0</td></tr>
<tr class="separator:a5c336b19e3c9b0db9a73b9515d7108d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07092693bb41ff97f5c376d2b3700ed1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a07092693bb41ff97f5c376d2b3700ed1">muteLocalVideoStream</a> (bool mute)=0</td></tr>
<tr class="separator:a07092693bb41ff97f5c376d2b3700ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a9d4a89d7d81419a1638af0a7e0be3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a65a9d4a89d7d81419a1638af0a7e0be3">muteLocalVideoStream</a> (<a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a> type, bool mute)=0</td></tr>
<tr class="separator:a65a9d4a89d7d81419a1638af0a7e0be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4ae2daa7bec91cc8e3cdafbcb95529"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#acd4ae2daa7bec91cc8e3cdafbcb95529">startScreenCaptureByScreenRect</a> (const <a class="el" href="structnertc_1_1_n_e_rtc_rectangle.html">NERtcRectangle</a> &amp;screen_rect, const <a class="el" href="structnertc_1_1_n_e_rtc_rectangle.html">NERtcRectangle</a> &amp;region_rect, const <a class="el" href="structnertc_1_1_n_e_rtc_screen_capture_parameters.html">NERtcScreenCaptureParameters</a> &amp;capture_params)=0</td></tr>
<tr class="separator:acd4ae2daa7bec91cc8e3cdafbcb95529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44615af019e079d240ed1f32d8348f11"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a44615af019e079d240ed1f32d8348f11">startScreenCaptureByDisplayId</a> (unsigned int display_id, const <a class="el" href="structnertc_1_1_n_e_rtc_rectangle.html">NERtcRectangle</a> &amp;region_rect, const <a class="el" href="structnertc_1_1_n_e_rtc_screen_capture_parameters.html">NERtcScreenCaptureParameters</a> &amp;capture_params)=0</td></tr>
<tr class="separator:a44615af019e079d240ed1f32d8348f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cc3d908fed71815a7a29339215e5ea"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a53cc3d908fed71815a7a29339215e5ea">startScreenCaptureByWindowId</a> (<a class="el" href="namespacenertc.html#a93322486d4e060256d5bff61c75fad53">source_id_t</a> window_id, const <a class="el" href="structnertc_1_1_n_e_rtc_rectangle.html">NERtcRectangle</a> &amp;region_rect, const <a class="el" href="structnertc_1_1_n_e_rtc_screen_capture_parameters.html">NERtcScreenCaptureParameters</a> &amp;capture_params)=0</td></tr>
<tr class="separator:a53cc3d908fed71815a7a29339215e5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e9d14fd2c5db3b1544f18a5bb67a02"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#ae0e9d14fd2c5db3b1544f18a5bb67a02">updateScreenCaptureRegion</a> (const <a class="el" href="structnertc_1_1_n_e_rtc_rectangle.html">NERtcRectangle</a> &amp;region_rect)=0</td></tr>
<tr class="separator:ae0e9d14fd2c5db3b1544f18a5bb67a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da427bab24d4fdae61c088330383f5e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a4da427bab24d4fdae61c088330383f5e">setScreenCaptureMouseCursor</a> (bool capture_cursor)=0</td></tr>
<tr class="separator:a4da427bab24d4fdae61c088330383f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa338cffad6abd1cd31f6a9ab0a2e5ed1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#aa338cffad6abd1cd31f6a9ab0a2e5ed1">stopScreenCapture</a> ()=0</td></tr>
<tr class="separator:aa338cffad6abd1cd31f6a9ab0a2e5ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c41396be7946df550e546043334a782"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a8c41396be7946df550e546043334a782">pauseScreenCapture</a> ()=0</td></tr>
<tr class="separator:a8c41396be7946df550e546043334a782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d15807d86187d0417632bc83aa7fb9"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a17d15807d86187d0417632bc83aa7fb9">resumeScreenCapture</a> ()=0</td></tr>
<tr class="separator:a17d15807d86187d0417632bc83aa7fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67423b097cdedc4b9899b4156de38cb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#aa67423b097cdedc4b9899b4156de38cb">setExcludeWindowList</a> (<a class="el" href="namespacenertc.html#a93322486d4e060256d5bff61c75fad53">source_id_t</a> *window_list, int count)=0</td></tr>
<tr class="separator:aa67423b097cdedc4b9899b4156de38cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3b133b7f0d76965eb098f895a69814"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a6b3b133b7f0d76965eb098f895a69814">updateScreenCaptureParameters</a> (const <a class="el" href="structnertc_1_1_n_e_rtc_screen_capture_parameters.html">nertc::NERtcScreenCaptureParameters</a> &amp;captureParams)=0</td></tr>
<tr class="separator:a6b3b133b7f0d76965eb098f895a69814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f35f36c7bf378d5e4c14eec337a2500"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a3f35f36c7bf378d5e4c14eec337a2500">setupLocalVideoCanvas</a> (<a class="el" href="structnertc_1_1_n_e_rtc_video_canvas.html">NERtcVideoCanvas</a> *canvas)=0</td></tr>
<tr class="separator:a3f35f36c7bf378d5e4c14eec337a2500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc83b37cf5398d051088eb763622f18"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#aebc83b37cf5398d051088eb763622f18">setupLocalSubStreamVideoCanvas</a> (<a class="el" href="structnertc_1_1_n_e_rtc_video_canvas.html">NERtcVideoCanvas</a> *canvas)=0</td></tr>
<tr class="separator:aebc83b37cf5398d051088eb763622f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad76fc9270c220d4c582f416463490b7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#aad76fc9270c220d4c582f416463490b7">setLocalRenderMode</a> (<a class="el" href="namespacenertc.html#a410a5b7182fad6ff52def434a58de4e5">NERtcVideoScalingMode</a> scaling_mode)=0</td></tr>
<tr class="separator:aad76fc9270c220d4c582f416463490b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accee985db847591fcf8122ca0df1aacb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#accee985db847591fcf8122ca0df1aacb">setLocalSubStreamRenderMode</a> (<a class="el" href="namespacenertc.html#a410a5b7182fad6ff52def434a58de4e5">NERtcVideoScalingMode</a> scaling_mode)=0</td></tr>
<tr class="separator:accee985db847591fcf8122ca0df1aacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b33bef358285686ebd67dc8b1a68b1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#aa4b33bef358285686ebd67dc8b1a68b1">setLocalVideoMirrorMode</a> (<a class="el" href="namespacenertc.html#aa3abbd3e5bbe492f54f9720d0b25d3f8">NERtcVideoMirrorMode</a> mirror_mode)=0</td></tr>
<tr class="separator:aa4b33bef358285686ebd67dc8b1a68b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb23c7a8ef637316507e3eb6793ae1e9"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#aeb23c7a8ef637316507e3eb6793ae1e9">setLocalVideoMirrorMode</a> (<a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a> type, <a class="el" href="namespacenertc.html#aa3abbd3e5bbe492f54f9720d0b25d3f8">NERtcVideoMirrorMode</a> mirror_mode)=0</td></tr>
<tr class="separator:aeb23c7a8ef637316507e3eb6793ae1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1288ec625e5b17892666cd5f70954a99"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a1288ec625e5b17892666cd5f70954a99">setupRemoteVideoCanvas</a> (<a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> uid, <a class="el" href="structnertc_1_1_n_e_rtc_video_canvas.html">NERtcVideoCanvas</a> *canvas)=0</td></tr>
<tr class="separator:a1288ec625e5b17892666cd5f70954a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6767fcbb866ec12dc1ee274f87c1c3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a6d6767fcbb866ec12dc1ee274f87c1c3">setupRemoteSubStreamVideoCanvas</a> (<a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> uid, <a class="el" href="structnertc_1_1_n_e_rtc_video_canvas.html">NERtcVideoCanvas</a> *canvas)=0</td></tr>
<tr class="separator:a6d6767fcbb866ec12dc1ee274f87c1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe8c3428784d9290e9842e89473040d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a0fe8c3428784d9290e9842e89473040d">setRemoteRenderMode</a> (<a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> uid, <a class="el" href="namespacenertc.html#a410a5b7182fad6ff52def434a58de4e5">NERtcVideoScalingMode</a> scaling_mode)=0</td></tr>
<tr class="separator:a0fe8c3428784d9290e9842e89473040d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd6e65efbf7a5dc6063dd32eb08b245"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a4bd6e65efbf7a5dc6063dd32eb08b245">setRemoteSubSteamRenderMode</a> (<a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> uid, <a class="el" href="namespacenertc.html#a410a5b7182fad6ff52def434a58de4e5">NERtcVideoScalingMode</a> scaling_mode)=0</td></tr>
<tr class="separator:a4bd6e65efbf7a5dc6063dd32eb08b245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b612e14b04eb8fc61b31484d536509"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a12b612e14b04eb8fc61b31484d536509">setClientRole</a> (<a class="el" href="namespacenertc.html#a1277b5498334b7efe3ad260d72350128">NERtcClientRole</a> role)=0</td></tr>
<tr class="separator:a12b612e14b04eb8fc61b31484d536509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b72cc5bea080f38b1665d655161edf"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#ae5b72cc5bea080f38b1665d655161edf">setLocalMediaPriority</a> (<a class="el" href="namespacenertc.html#a593accc20cb8c058a67f86f7ad785790">NERtcMediaPriorityType</a> priority, bool is_preemptive)=0</td></tr>
<tr class="separator:ae5b72cc5bea080f38b1665d655161edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fe893945782bd2f894df5f02c5bd26"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacenertc.html#a63c54360dd23ac659013f1e5031bd1d5">NERtcConnectionStateType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a70fe893945782bd2f894df5f02c5bd26">getConnectionState</a> ()=0</td></tr>
<tr class="separator:a70fe893945782bd2f894df5f02c5bd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ec83d0bff16e3148c141bd1f6a2abb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#ae5ec83d0bff16e3148c141bd1f6a2abb">setCameraCaptureConfig</a> (const <a class="el" href="structnertc_1_1_n_e_rtc_camera_capture_config.html">NERtcCameraCaptureConfig</a> &amp;config)=0</td></tr>
<tr class="separator:ae5ec83d0bff16e3148c141bd1f6a2abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cebba9bb1f98aa8ab14e89ab0cd742"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a70cebba9bb1f98aa8ab14e89ab0cd742">setCameraCaptureConfig</a> (<a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a> type, const <a class="el" href="structnertc_1_1_n_e_rtc_camera_capture_config.html">NERtcCameraCaptureConfig</a> &amp;config)=0</td></tr>
<tr class="separator:a70cebba9bb1f98aa8ab14e89ab0cd742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6236eb1eba4e3d34d9522cbbd84d782"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#ae6236eb1eba4e3d34d9522cbbd84d782">setVideoConfig</a> (const <a class="el" href="structnertc_1_1_n_e_rtc_video_config.html">NERtcVideoConfig</a> &amp;config)=0</td></tr>
<tr class="separator:ae6236eb1eba4e3d34d9522cbbd84d782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a6af7d6825b548b6a5775ceb76bc6d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a92a6af7d6825b548b6a5775ceb76bc6d">setVideoConfig</a> (<a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a> type, const <a class="el" href="structnertc_1_1_n_e_rtc_video_config.html">NERtcVideoConfig</a> &amp;config)=0</td></tr>
<tr class="separator:a92a6af7d6825b548b6a5775ceb76bc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00522dd52a04cb256b5ac0d3c845b6c2"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a00522dd52a04cb256b5ac0d3c845b6c2">enableDualStreamMode</a> (bool enable)=0</td></tr>
<tr class="separator:a00522dd52a04cb256b5ac0d3c845b6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a98f198738b466f36fadfb26035baa7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a5a98f198738b466f36fadfb26035baa7">subscribeRemoteAudioStream</a> (<a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> uid, bool subscribe)=0</td></tr>
<tr class="separator:a5a98f198738b466f36fadfb26035baa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7907c459ccb5278fc3adfc685afe5b4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#ad7907c459ccb5278fc3adfc685afe5b4">subscribeRemoteSubStreamAudio</a> (<a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> uid, bool subscribe)=0</td></tr>
<tr class="separator:ad7907c459ccb5278fc3adfc685afe5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0784ea010737d143f34df789dcd051e2"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a0784ea010737d143f34df789dcd051e2">subscribeAllRemoteAudioStream</a> (bool subscribe)=0</td></tr>
<tr class="separator:a0784ea010737d143f34df789dcd051e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fb83d15f988140d47e9217b427104c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a97fb83d15f988140d47e9217b427104c">setAudioSubscribeOnlyBy</a> (<a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> *uid_array, uint32_t size)=0</td></tr>
<tr class="separator:a97fb83d15f988140d47e9217b427104c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256c38c14427923a69b2de067cd037dc"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a256c38c14427923a69b2de067cd037dc">setSubscribeAudioAllowlist</a> (<a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> *uid_array, uint32_t size)=0</td></tr>
<tr class="separator:a256c38c14427923a69b2de067cd037dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a348216eeeeebb3549078f73faa8d85"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a5a348216eeeeebb3549078f73faa8d85">setSubscribeAudioBlocklist</a> (<a class="el" href="namespacenertc.html#a80f28ee70a6ad8a9cb24981313b0059b">NERtcAudioStreamType</a> type, <a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> *uid_array, uint32_t size)=0</td></tr>
<tr class="separator:a5a348216eeeeebb3549078f73faa8d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d5217a88d92f69948c3fa1da425387"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a28d5217a88d92f69948c3fa1da425387">subscribeRemoteVideoStream</a> (<a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> uid, <a class="el" href="namespacenertc.html#af9a1648ac76c0c9682bdadeca2f5c80d">NERtcRemoteVideoStreamType</a> type, bool subscribe)=0</td></tr>
<tr class="separator:a28d5217a88d92f69948c3fa1da425387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced63407cd6d002c598585240ee0fe60"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#aced63407cd6d002c598585240ee0fe60">subscribeRemoteVideoSubStream</a> (<a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> uid, bool subscribe)=0</td></tr>
<tr class="separator:aced63407cd6d002c598585240ee0fe60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd04f5c8c7733bc661ba32137e978e9"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a3fd04f5c8c7733bc661ba32137e978e9">addLiveStreamTask</a> (const <a class="el" href="structnertc_1_1_n_e_rtc_live_stream_task_info.html">NERtcLiveStreamTaskInfo</a> &amp;info)=0</td></tr>
<tr class="separator:a3fd04f5c8c7733bc661ba32137e978e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2570d5b8ed903d0bd086a619f4c84fe5"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a2570d5b8ed903d0bd086a619f4c84fe5">updateLiveStreamTask</a> (const <a class="el" href="structnertc_1_1_n_e_rtc_live_stream_task_info.html">NERtcLiveStreamTaskInfo</a> &amp;info)=0</td></tr>
<tr class="separator:a2570d5b8ed903d0bd086a619f4c84fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f7f8aeed2c95bb5852e8a8b0cf9232"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#af1f7f8aeed2c95bb5852e8a8b0cf9232">removeLiveStreamTask</a> (const char *task_id)=0</td></tr>
<tr class="separator:af1f7f8aeed2c95bb5852e8a8b0cf9232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d0ebc2b2de0d3f92c4eda5fcc756dc"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a30d0ebc2b2de0d3f92c4eda5fcc756dc">sendSEIMsg</a> (const char *data, int length, <a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a> type)=0</td></tr>
<tr class="separator:a30d0ebc2b2de0d3f92c4eda5fcc756dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170f18f35a304f2191af9463b9e13277"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a170f18f35a304f2191af9463b9e13277">sendSEIMsg</a> (const char *data, int length)=0</td></tr>
<tr class="separator:a170f18f35a304f2191af9463b9e13277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605e0480cb41fcc692f5eb6b1ca28cb9"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a605e0480cb41fcc692f5eb6b1ca28cb9">takeLocalSnapshot</a> (<a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a> stream_type, <a class="el" href="classnertc_1_1_n_e_rtc_take_snapshot_callback.html">NERtcTakeSnapshotCallback</a> *callback)=0</td></tr>
<tr class="separator:a605e0480cb41fcc692f5eb6b1ca28cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85102b0bc44d35050693eeea4c9f79f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#af85102b0bc44d35050693eeea4c9f79f">takeRemoteSnapshot</a> (<a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> uid, <a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a> stream_type, <a class="el" href="classnertc_1_1_n_e_rtc_take_snapshot_callback.html">NERtcTakeSnapshotCallback</a> *callback)=0</td></tr>
<tr class="separator:af85102b0bc44d35050693eeea4c9f79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf7d8c56e4665d58d6ffb58dc7ea491"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#abbf7d8c56e4665d58d6ffb58dc7ea491">adjustUserPlaybackSignalVolume</a> (<a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> uid, int volume)=0</td></tr>
<tr class="separator:abbf7d8c56e4665d58d6ffb58dc7ea491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09987f0e104551df5ef56c883737d0e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#aa09987f0e104551df5ef56c883737d0e">adjustChannelPlaybackSignalVolume</a> (uint32_t volume)=0</td></tr>
<tr class="separator:aa09987f0e104551df5ef56c883737d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a5ad482b2ec85cb76767f05ef072dd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#ac4a5ad482b2ec85cb76767f05ef072dd">startChannelMediaRelay</a> (<a class="el" href="structnertc_1_1_n_e_rtc_channel_media_relay_configuration.html">NERtcChannelMediaRelayConfiguration</a> *config)=0</td></tr>
<tr class="separator:ac4a5ad482b2ec85cb76767f05ef072dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5d3a58a6fa18a2e43c6b7cc3537fe2"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#ade5d3a58a6fa18a2e43c6b7cc3537fe2">updateChannelMediaRelay</a> (<a class="el" href="structnertc_1_1_n_e_rtc_channel_media_relay_configuration.html">NERtcChannelMediaRelayConfiguration</a> *config)=0</td></tr>
<tr class="separator:ade5d3a58a6fa18a2e43c6b7cc3537fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4dde6895c937eac0b88a852a90796d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a0e4dde6895c937eac0b88a852a90796d">stopChannelMediaRelay</a> ()=0</td></tr>
<tr class="separator:a0e4dde6895c937eac0b88a852a90796d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2aeae78634a66cf2b5262ba933c1df"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a5d2aeae78634a66cf2b5262ba933c1df">setLocalPublishFallbackOption</a> (<a class="el" href="namespacenertc.html#a1f81e05e0a5bbcd0807479d4b1c03d06">NERtcStreamFallbackOption</a> option)=0</td></tr>
<tr class="separator:a5d2aeae78634a66cf2b5262ba933c1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6486d19b8dd550149b31e7a19ab7d4d3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a6486d19b8dd550149b31e7a19ab7d4d3">setRemoteSubscribeFallbackOption</a> (<a class="el" href="namespacenertc.html#a1f81e05e0a5bbcd0807479d4b1c03d06">NERtcStreamFallbackOption</a> option)=0</td></tr>
<tr class="separator:a6486d19b8dd550149b31e7a19ab7d4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d04c6b4e6559bcf9c2f79a15b7e26e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a87d04c6b4e6559bcf9c2f79a15b7e26e">setRemoteHighPriorityAudioStream</a> (bool enabled, <a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> uid)=0</td></tr>
<tr class="separator:a87d04c6b4e6559bcf9c2f79a15b7e26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec51e2fbb70c3421c07eca49217f57a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#afec51e2fbb70c3421c07eca49217f57a">setExternalVideoSource</a> (bool enabled)=0</td></tr>
<tr class="separator:afec51e2fbb70c3421c07eca49217f57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecc35c54940975f666235843e0a2da3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#afecc35c54940975f666235843e0a2da3">setExternalVideoSource</a> (<a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a> type, bool enabled)=0</td></tr>
<tr class="separator:afecc35c54940975f666235843e0a2da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bd589253324487fddc327cbd298a7a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a32bd589253324487fddc327cbd298a7a">pushExternalVideoFrame</a> (<a class="el" href="structnertc_1_1_n_e_rtc_video_frame.html">NERtcVideoFrame</a> *frame)=0</td></tr>
<tr class="separator:a32bd589253324487fddc327cbd298a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42bc7c15dab5ecaf4d911afde595b18"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#ae42bc7c15dab5ecaf4d911afde595b18">pushExternalVideoFrame</a> (<a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a> type, <a class="el" href="structnertc_1_1_n_e_rtc_video_frame.html">NERtcVideoFrame</a> *frame)=0</td></tr>
<tr class="separator:ae42bc7c15dab5ecaf4d911afde595b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4150cf7de0bec23523a216c978245c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#add4150cf7de0bec23523a216c978245c">enableMediaPub</a> (bool enabled, <a class="el" href="namespacenertc.html#ab5f542d6434b5b23b66c82f39be9e8be">NERtcMediaPubType</a> media_type)=0</td></tr>
<tr class="separator:add4150cf7de0bec23523a216c978245c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75a680086ecade7d05f971e516409c4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#ab75a680086ecade7d05f971e516409c4">updatePermissionKey</a> (const char *key)=0</td></tr>
<tr class="separator:ab75a680086ecade7d05f971e516409c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea86f48b384d6a7a6cf53b945b00324c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#aea86f48b384d6a7a6cf53b945b00324c">reportCustomEvent</a> (const char *event_name, const char *custom_identify, const char *parameters)=0</td></tr>
<tr class="separator:aea86f48b384d6a7a6cf53b945b00324c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241d2f23c37a28c907fa9d2c291e8f1d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a241d2f23c37a28c907fa9d2c291e8f1d">enableAudioVolumeIndication</a> (bool enable, uint64_t interval, bool enable_vad)=0</td></tr>
<tr class="separator:a241d2f23c37a28c907fa9d2c291e8f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad245bb0f193db33ff2508336f09e7611"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#ad245bb0f193db33ff2508336f09e7611">setRangeAudioMode</a> (<a class="el" href="namespacenertc.html#a64b693fd44286322cd9d4957b0e0a763">NERtcRangeAudioMode</a> mode)=0</td></tr>
<tr class="separator:ad245bb0f193db33ff2508336f09e7611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ea9533db5469ad79b2a07944967f81"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a88ea9533db5469ad79b2a07944967f81">setRangeAudioTeamID</a> (int32_t team_id)=0</td></tr>
<tr class="separator:a88ea9533db5469ad79b2a07944967f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0317f9c66afe19ebd7718be42442790"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#ac0317f9c66afe19ebd7718be42442790">setAudioRecvRange</a> (int audible_distance, int conversational_distance, <a class="el" href="namespacenertc.html#aed5324bd7a40767f0f2c6ae857fa9e2c">NERtcDistanceRolloffModel</a> roll_off)=0</td></tr>
<tr class="separator:ac0317f9c66afe19ebd7718be42442790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4e7c404d47e33f4a1cbff1f1284dfb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a8a4e7c404d47e33f4a1cbff1f1284dfb">updateSelfPosition</a> (const <a class="el" href="structnertc_1_1_n_e_rtc_position_info.html">NERtcPositionInfo</a> &amp;info)=0</td></tr>
<tr class="separator:a8a4e7c404d47e33f4a1cbff1f1284dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c014ecacb3bba8ce64aa62af107af17"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a2c014ecacb3bba8ce64aa62af107af17">enableSpatializerRoomEffects</a> (bool enable)=0</td></tr>
<tr class="separator:a2c014ecacb3bba8ce64aa62af107af17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c23b9778c38db526288df4bb0981f3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a02c23b9778c38db526288df4bb0981f3">setSpatializerRoomProperty</a> (const <a class="el" href="structnertc_1_1_n_e_rtc_spatializer_room_property.html">NERtcSpatializerRoomProperty</a> &amp;room_property)=0</td></tr>
<tr class="separator:a02c23b9778c38db526288df4bb0981f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba6dcb73a38571d740dd0a1ef3f2cef"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a3ba6dcb73a38571d740dd0a1ef3f2cef">setSpatializerRenderMode</a> (<a class="el" href="namespacenertc.html#a79ef6ed6b3b86c72c3b42f9736fe32c9">NERtcSpatializerRenderMode</a> mode)=0</td></tr>
<tr class="separator:a3ba6dcb73a38571d740dd0a1ef3f2cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4a30c0749cd8fd82dde57796e86c2b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a1f4a30c0749cd8fd82dde57796e86c2b">initSpatializer</a> ()=0</td></tr>
<tr class="separator:a1f4a30c0749cd8fd82dde57796e86c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e22a70ba1c0ab41b03c49ea86ba8ad6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_channel.html#a5e22a70ba1c0ab41b03c49ea86ba8ad6">enableSpatializer</a> (bool enable, bool apply_to_team)=0</td></tr>
<tr class="separator:a5e22a70ba1c0ab41b03c49ea86ba8ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p><a class="el" href="classnertc_1_1_i_rtc_channel.html">IRtcChannel</a> 类在指定房间中实现实时音视频功能。通过创建多个 <a class="el" href="classnertc_1_1_i_rtc_channel.html">IRtcChannel</a> 对象，用户可以同时加入多个房间。 </p>
</div><h2 class="groupheader">成员函数说明</h2>
<a id="a3fd04f5c8c7733bc661ba32137e978e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd04f5c8c7733bc661ba32137e978e9">&#9670;&nbsp;</a></span>addLiveStreamTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::addLiveStreamTask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnertc_1_1_n_e_rtc_live_stream_task_info.html">NERtcLiveStreamTaskInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>添加房间内推流任务。 通过此接口可以实现增加一路旁路推流任务；若需推送多路流，则需多次调用该方法。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>使用前提</dt><dd>请先通过 <a class="el" href="classnertc_1_1_i_rtc_engine.html#a6195db00acf739ca2cb183015abffd5b">setChannelProfile</a> 接口设置房间模式为直播模式。 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化之后调用此接口，且该方法仅可在加入房间后调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>仅角色为主播的房间成员能调用此接口，观众成员无相关推流权限。</li>
<li>同一个音视频房间（即同一个 channelId）可以创建 6 个不同的推流任务。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>info </td><td><a class="el" href="structnertc_1_1_n_e_rtc_live_stream_task_info.html">NERtcLiveStreamTaskInfo</a> </td><td>推流任务信息。  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line">NERtcLiveStreamTaskInfo info;</div>
<div class="line">strncpy(info.task_id, <span class="stringliteral">&quot;task1&quot;</span>, <a class="code" href="nertc__engine__defines_8h.html#a1c9cd2c7797e56bb6b042dc8e3796224">kNERtcMaxTaskIDLength</a>);</div>
<div class="line">strncpy(info.stream_url, <span class="stringliteral">&quot;rtmp://pxxxxxx.live.126.net/live/xxxxxx&quot;</span>, <a class="code" href="nertc__engine__defines_8h.html#ae2c60b83e3f6d41939696a9413654915">kNERtcMaxURILength</a>);</div>
<div class="line">info.ls_mode = <a class="code" href="namespacenertc.html#aa42163972b1312e5daa8de1a48e402bead5290a371434823aaf54e798e539291d">kNERtcLsModeVideo</a>;</div>
<div class="line">info.server_record_enabled = <span class="keyword">false</span>;</div>
<div class="line"><span class="comment">//扩展推流信息info.config.single_video_passthrough = false;</span></div>
<div class="line">info.config.audio_bitrate = 64;</div>
<div class="line">info.config.audioCodecProfile = <a class="code" href="namespacenertc.html#ae8f20f9dce3c8b14b0d20bf5024d64ffa590a13b5e55870942210672e8318dfe6">nertc::kNERtcLiveStreamAudioCodecProfileLCAAC</a>;</div>
<div class="line">info.config.channels = 2;</div>
<div class="line">info.config.sampleRate = <a class="code" href="namespacenertc.html#a6a21d6c0b87fcb8c99029f8cec6daa3ea2cc1b83007c26968979497b41b63aeaa">nertc::kNERtcLiveStreamAudioSampleRate48000</a>;</div>
<div class="line"><span class="comment">//流基础信息info.layout.background_color = 0;</span></div>
<div class="line">info.layout.width = 1280;</div>
<div class="line">info.layout.height = 720;</div>
<div class="line">info.layout.bg_image = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="comment">//流成员信息</span></div>
<div class="line">info.layout.user_count = 2;</div>
<div class="line">info.layout.users = <span class="keyword">new</span> NERtcLiveStreamUserTranscoding[info.layout.user_count];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; info.layout.user_count; i++) {</div>
<div class="line">info.layout.users[i].uid = 0;</div>
<div class="line">info.layout.users[i].adaption = <a class="code" href="namespacenertc.html#a6eca559465693afacac1802e5733b60ba8df1adaeb670e2e8b506acbe76292129">kNERtcLsModeVideoScaleFit</a>;</div>
<div class="line">info.layout.users[i].video_push = <span class="keyword">true</span>;</div>
<div class="line">info.layout.users[i].x = 0;</div>
<div class="line">info.layout.users[i].y = 0;</div>
<div class="line">info.layout.users[i].width = 640;</div>
<div class="line">info.layout.users[i].height = 480;</div>
<div class="line">info.layout.users[i].audio_push = <span class="keyword">true</span>;</div>
<div class="line">info.layout.users[i].z_order = 0;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (rtc_channel_) {</div>
<div class="line"><span class="keywordtype">int</span> res = rtc_channel_-&gt;addLiveStreamTask(info);</div>
<div class="line">}</div>
<div class="line"><span class="keyword">delete</span>[] info.layout.users;</div>
<div class="ttc" id="anamespacenertc_html_a6a21d6c0b87fcb8c99029f8cec6daa3ea2cc1b83007c26968979497b41b63aeaa"><div class="ttname"><a href="namespacenertc.html#a6a21d6c0b87fcb8c99029f8cec6daa3ea2cc1b83007c26968979497b41b63aeaa">nertc::kNERtcLiveStreamAudioSampleRate48000</a></div><div class="ttdeci">@ kNERtcLiveStreamAudioSampleRate48000</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:830</div></div>
<div class="ttc" id="anamespacenertc_html_a6eca559465693afacac1802e5733b60ba8df1adaeb670e2e8b506acbe76292129"><div class="ttname"><a href="namespacenertc.html#a6eca559465693afacac1802e5733b60ba8df1adaeb670e2e8b506acbe76292129">nertc::kNERtcLsModeVideoScaleFit</a></div><div class="ttdeci">@ kNERtcLsModeVideoScaleFit</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:467</div></div>
<div class="ttc" id="anamespacenertc_html_aa42163972b1312e5daa8de1a48e402bead5290a371434823aaf54e798e539291d"><div class="ttname"><a href="namespacenertc.html#aa42163972b1312e5daa8de1a48e402bead5290a371434823aaf54e798e539291d">nertc::kNERtcLsModeVideo</a></div><div class="ttdeci">@ kNERtcLsModeVideo</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:436</div></div>
<div class="ttc" id="anamespacenertc_html_ae8f20f9dce3c8b14b0d20bf5024d64ffa590a13b5e55870942210672e8318dfe6"><div class="ttname"><a href="namespacenertc.html#ae8f20f9dce3c8b14b0d20bf5024d64ffa590a13b5e55870942210672e8318dfe6">nertc::kNERtcLiveStreamAudioCodecProfileLCAAC</a></div><div class="ttdeci">@ kNERtcLiveStreamAudioCodecProfileLCAAC</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:850</div></div>
<div class="ttc" id="anertc__engine__defines_8h_html_a1c9cd2c7797e56bb6b042dc8e3796224"><div class="ttname"><a href="nertc__engine__defines_8h.html#a1c9cd2c7797e56bb6b042dc8e3796224">kNERtcMaxTaskIDLength</a></div><div class="ttdeci">#define kNERtcMaxTaskIDLength</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:88</div></div>
<div class="ttc" id="anertc__engine__defines_8h_html_ae2c60b83e3f6d41939696a9413654915"><div class="ttname"><a href="nertc__engine__defines_8h.html#ae2c60b83e3f6d41939696a9413654915">kNERtcMaxURILength</a></div><div class="ttdeci">#define kNERtcMaxURILength</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:79</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd><a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a0301ccc130b1714f39f7e86b89ab995f">onAddLiveStreamTask</a>：推流任务已成功添加回调。 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a16bf1ed05a44102458c587bc59cb140f">onAddLiveStreamTask</a>：推流任务状态已改变回调。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功；</li>
<li>其他：方法调用失败。<ul>
<li>403（kNERtcErrChannelReservePermissionDenied）：权限不足，观众模式下不支持此操作。</li>
<li>30005（kNERtcErrInvalidState）：当前状态不支持的操作，比如引擎尚未初始化。</li>
<li>30101（kNERtcErrChannelNotJoined）：尚未加入房间。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa09987f0e104551df5ef56c883737d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09987f0e104551df5ef56c883737d0e">&#9670;&nbsp;</a></span>adjustChannelPlaybackSignalVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::adjustChannelPlaybackSignalVolume </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>volume</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>调节本地播放的指定房间的所有远端用户的信号音量。 <br  />
通过此接口可以实现在通话过程中随时调节指定房间内的所有远端用户在本地播放的混音音量。 </p><dl class="section since"><dt>自从</dt><dd>V4.6.50 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化之后调用此接口，且该方法仅可在加入房间后调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>该方法设置内部引擎为启用状态，在 leaveChannel 后失效，但在本次通话过程中有效 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>volume </td><td>uint64_t </td><td>播放音量，取值范围为 [0,400]。<ul>
<li>
0：静音。</li>
<li>
100：原始音量。</li>
<li>
400：最大可为原始音量的 4 倍（自带溢出保护）。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30005（kNERtcErrInvalidState）：状态错误。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="abbf7d8c56e4665d58d6ffb58dc7ea491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf7d8c56e4665d58d6ffb58dc7ea491">&#9670;&nbsp;</a></span>adjustUserPlaybackSignalVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::adjustUserPlaybackSignalVolume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a>&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>volume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>调节本地播放的指定远端用户的信号音量。 <br  />
通过此接口可以实现在通话过程中随时调节指定远端用户在本地播放的混音音量。 </p><dl class="section since"><dt>自从</dt><dd>V4.2.1 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化之后调用此接口，且该方法仅可在加入房间后调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>该方法设置内部引擎为启用状态，在 leaveChannel 后失效，但在本次通话过程中有效，比如指定远端用户中途退出房间，则再次加入此房间时仍旧维持该设置。</li>
<li>该方法每次只能调整一位远端用户的播放音量，若需调整多位远端用户在本地播放的音量，则需多次调用该方法。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明 </dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>uid </td><td>uid_t </td><td>远端用户 ID。  </td></tr>
<tr>
<td>volume </td><td>int </td><td>播放音量，取值范围为 0 ~ 400。<ul>
<li>
0：静音。</li>
<li>
100（默认）：原始音量。</li>
<li>
400：最大音量值（自带溢出保护）。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//调整uid为12345的用户在本地的播放音量为50</span></div>
<div class="line">rtc_channel_-&gt;adjustUserPlaybackSignalVolume(12345, 50);</div>
<div class="line"><span class="comment">//调整uid为12345的用户在本地的播放音量为0，静音该用户。</span></div>
<div class="line">rtc_channel_-&gt;adjustUserPlaybackSignalVolume(12345, 0);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30005（kNERtcErrInvalidState）：状态错误，比如引擎未初始化。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a241d2f23c37a28c907fa9d2c291e8f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241d2f23c37a28c907fa9d2c291e8f1d">&#9670;&nbsp;</a></span>enableAudioVolumeIndication()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::enableAudioVolumeIndication </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_vad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">弃用:</a></b></dt><dd>这个方法已废弃。 启用说话者音量提示。 <br  />
通过此接口可以实现允许 SDK 定期向 App 反馈房间内发音频流的用户和瞬时音量最高的远端用户（最多 3 位，包括本端）的音量相关信息，即当前谁在说话以及说话者的音量。 </dd></dl>
<dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化之后调用此接口，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section user"><dt>业务场景</dt><dd>适用于通过发言者的人声相关信息做出 UI 上的音量展示的场景，或根据发言者的音量大小进行视图布局的动态调整。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>该方法在 leaveChannel 后设置失效，将恢复至默认。如果您离开房间后重新加入房间，需要重新调用本接口。 </dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>enable </td><td>bool </td><td>是否启用说话者音量提示：<ul>
<li>
true：启用说话者音量提示。</li>
<li>
false：关闭说话者音量提示。 </li>
</ul>
</td></tr>
<tr>
<td>interval </td><td>uint64_t </td><td>指定音量提示的时间间隔。单位为毫秒。必须设置为 100 毫秒的整数倍值，建议设置为 200 毫秒以上。  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//设置间隔为500ms的人声音量提示</span></div>
<div class="line">rtc_engine_-&gt;enableAudioVolumeIndication(<span class="keyword">true</span>, 500);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd>启用该方法后，只要房间内有发流用户，无论是否有人说话，SDK 都会在加入房间后根据预设的时间间隔触发 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler_ex.html#a5917377045d6151993c6866e28b40464">onRemoteAudioVolumeIndication</a> 回调。 </dd></dl>
<dl class="section user"><dt>相关接口</dt><dd>若您希望在返回音量相关信息的同时检测是否有真实人声存在，请调用 <a class="el" href="classnertc_1_1_i_rtc_engine_ex.html#a81ed65dc33d5067ce739cf9ddd267694">nertc::IRtcEngineEx::enableAudioVolumeIndication</a>(bool enable, uint64_t interval, bool enable_vad) "enableAudioVolumeIndication" 方法。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30003（kNERtcErrInvalidParam）：参数错误，比如时间间隔小于 100ms。</li>
<li>30005（kNERtcErrInvalidState）：状态错误，比如引擎未初始化。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a00522dd52a04cb256b5ac0d3c845b6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00522dd52a04cb256b5ac0d3c845b6c2">&#9670;&nbsp;</a></span>enableDualStreamMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::enableDualStreamMode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置是否开启视频大小流模式。 <br  />
 通过本接口可以实现设置单流或者双流模式。发送端开启双流模式后，接收端可以选择接收大流还是小流。其中，大流指高分辨率、高码率的视频流，小流指低分辨率、低码率的视频流。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机 </dt><dd>请在初始化后调用该方法，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>纯音频 SDK 禁用该接口，如需使用请前往<a href="https://doc.yunxin.163.com/nertc/sdk-download" target="_blank">云信官网</a>下载并替换成视频 SDK。</li>
<li>该方法只对摄像头数据生效，对自定义输入、屏幕共享等视频流无效。</li>
<li>该接口的设置会在摄像头重启后生效。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>enable </td><td>boolean </td><td>是否开启双流模式：<ul>
<li>
true：开启双流模式。</li>
<li>
false：关闭双流模式。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line">rtc_channel-&gt;enableDualStreamMode(<span class="keyword">true</span>);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30005（kNERtcErrInvalidState）：当前状态不支持的操作，比如引擎尚未初始化。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac746f2cd380bbfeee1a0d56957a387aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac746f2cd380bbfeee1a0d56957a387aa">&#9670;&nbsp;</a></span>enableLocalAudio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::enableLocalAudio </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>开启/关闭本地音频采集和发送。 <br  />
通过本接口可以实现开启或关闭本地语音功能，进行本地音频采集及处理。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化之后调用此接口，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>加入房间后，语音功能默认为开启状态。</li>
<li>该方法设置内部引擎为启用状态，在 leaveChannel 后仍然有效。</li>
<li>该方法不影响接收或播放远端音频流，enableLocalAudio(false) 适用于只下行不上行音频流的场景。</li>
<li>该方法会操作音频硬件设备，建议避免频繁开关，否则可能导致设备异常。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>enabled </td><td>boolean </td><td>是否启用本地音频的采集和发送：<ul>
<li>
true：开启本地音频采集。</li>
<li>
false：关闭本地音频采集。关闭后，远端用户会接收不到本地用户的音频流；但本地用户依然可以接收到远端用户的音频流。  </li>
</ul>
</td></tr>
</table>
<br  />
 </dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//打开音频采集</span></div>
<div class="line">rtc_channel_-&gt;enableLocalAudio(<span class="keyword">true</span>);</div>
<div class="line"><span class="comment">//关闭音频采集</span></div>
<div class="line">rtc_channel_-&gt;enableLocalAudio(<span class="keyword">false</span>);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd><ul>
<li>开启音频采集后，远端会触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a19d733386e2e6b00ea33cce847112b67">onUserAudioStart</a> 回调。</li>
<li>关闭音频采集后，远端会触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a000eb885c3743c061f76ce3b03583a3d">onUserAudioStop</a> 回调。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>相关接口</dt><dd><a class="el" href="classnertc_1_1_i_rtc_channel.html#a5d276b222652330d9c88ec6d2f276ea9">muteLocalAudioStream</a>：两者的差异在于，enableLocalAudio 用于开启本地语音采集及处理，而 muteLocalAudioStream 用于停止或继续发送本地音频流。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30005（kNERtcErrInvalidState）：引擎尚未初始化，或者多房间场景下未在本房间操作。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="abfa535557adb2f412ce32e6709b41d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa535557adb2f412ce32e6709b41d38">&#9670;&nbsp;</a></span>enableLocalSubStreamAudio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::enableLocalSubStreamAudio </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>开启或关闭音频辅流。 <br  />
开启时远端会收到 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a69a40ccee6764c01482f5eab32db9e57">onUserSubStreamAudioStart</a>，关闭时远端会收到 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#ab695bf041e188504ff10a5cf4efb4329">onUserSubStreamAudioStop</a>。 </p><dl class="section note"><dt>注解</dt><dd>该方法设置内部引擎为启用状态，在 <a class="el" href="classnertc_1_1_i_rtc_channel.html#ac83171f8a9d2a9f7408fd37c5d64293f">leaveChannel</a> 后仍然有效。 </dd></dl>
<dl class="section since"><dt>自从</dt><dd>V4.6.10 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enabled</td><td>是否开启音频辅流。<ul>
<li>true: 开启音频辅流。</li>
<li>false: 关闭音频辅流。 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功；</li>
<li>其他: 方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aba1054b2bb49c402013b62faf170bd2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba1054b2bb49c402013b62faf170bd2c">&#9670;&nbsp;</a></span>enableLocalVideo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::enableLocalVideo </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>开启或关闭本地视频的采集与发送。 <br  />
通过本接口可以实现开启或关闭本地视频，不影响接收远端视频。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机 </dt><dd>请在初始化后调用该方法，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>纯音频 SDK 禁用该接口，如需使用请前往<a href="https://doc.yunxin.163.com/nertc/sdk-download" target="_blank">云信官网</a>下载并替换成视频 SDK。</li>
<li>该方法设置内部引擎为开启或关闭状态, 在 <a class="el" href="classnertc_1_1_i_rtc_channel.html#ac83171f8a9d2a9f7408fd37c5d64293f">leaveChannel</a> 后仍然有效。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>enabled </td><td>bool </td><td>是否开启本地视频采集与发送：<ul>
<li>
true：开启本地视频采集。</li>
<li>
false：关闭本地视频采集，此时不需要本地有摄像头。关闭后，远端用户无法接收到本地用户的视频流；但本地用户仍然可以接收到远端用户的视频流。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//打开视频</span></div>
<div class="line">rtc_channel_-&gt;enableLocalVideo(<span class="keyword">true</span>);</div>
<div class="line"><span class="comment">//关闭视频</span></div>
<div class="line">rtc_channel_-&gt;enableLocalVideo(<span class="keyword">false</span>);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd><ul>
<li>开启本地视频采集后，远端会收到 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a79d4564ddd9364665ea6b5acd775b794">onUserVideoStart</a> 回调。</li>
<li>关闭本地视频采集后，远端会收到 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a85560d0d2adc7718a5706a8a4362f7c9">onUserVideoStop</a> 回调。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>相关接口</dt><dd>若您希望开启辅流通道的视频采集，请调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#a5c336b19e3c9b0db9a73b9515d7108d7">enableLocalVideo</a> 方法。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30001（kNERtcErrFatal）：通用错误，一般表示引擎错误，尝试再次调用此接口即可。</li>
<li>30005（kNERtcErrInvalidState）：当前状态不支持的操作，比如已开启外部视频采集。</li>
<li>50000（kNERtcRuntimeErrVDMNoAuthorize）：应用未获取到操作系统的摄像头权限。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5c336b19e3c9b0db9a73b9515d7108d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c336b19e3c9b0db9a73b9515d7108d7">&#9670;&nbsp;</a></span>enableLocalVideo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::enableLocalVideo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>开启或关闭本地视频的采集与发送。 <br  />
通过主流或辅流视频通道进行本地视频流的采集与发送。 </p><dl class="section since"><dt>自从</dt><dd>V4.6.20 </dd></dl>
<dl class="section user"><dt>调用时机 </dt><dd>请在初始化后调用该方法，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>纯音频 SDK 禁用该接口，如需使用请前往<a href="https://doc.yunxin.163.com/nertc/sdk-download" target="_blank">云信官网</a>下载并替换成视频 SDK。</li>
<li>该方法仅适用于视频主流，若您希望开启辅流通道的视频采集，请调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#a5c336b19e3c9b0db9a73b9515d7108d7">enableLocalVideo</a> 方法。</li>
<li>该方法设置内部引擎为开启或关闭状态, 在 <a class="el" href="classnertc_1_1_i_rtc_engine.html#a6fbc54a71986a4a4a1c9c24d2c29e884">leaveChannel</a> 后仍然有效。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>type </td><td><a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a> </td><td>视频通道类型：<ul>
<li>
kNERTCVideoStreamMain：主流。</li>
<li>
kNERTCVideoStreamSub：辅流。  </li>
</ul>
</td></tr>
<tr>
<td>enabled </td><td>bool </td><td>是否开启本地视频采集与发送：<ul>
<li>
true：开启本地视频采集。</li>
<li>
false：关闭本地视频采集，此时不需要本地有摄像头。关闭后，远端用户无法接收到本地用户的视频流；但本地用户仍然可以接收到远端用户的视频流。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//打开视频主流</span></div>
<div class="line"><a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">nertc::NERtcVideoStreamType</a> type = <a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a15fcc7ab62484b7ed86661f6e7188a09">nertc::NERtcVideoStreamType::kNERTCVideoStreamMain</a>;</div>
<div class="line"><span class="keywordtype">bool</span> enable = <span class="keyword">true</span>;</div>
<div class="line">rtc_channel_-&gt;enableLocalVideo(type, enable);</div>
<div class="line"><span class="comment">//关闭视频主流</span></div>
<div class="line"><a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">nertc::NERtcVideoStreamType</a> type = <a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a15fcc7ab62484b7ed86661f6e7188a09">nertc::NERtcVideoStreamType::kNERTCVideoStreamMain</a>;</div>
<div class="line"><span class="keywordtype">bool</span> enable = <span class="keyword">false</span>;</div>
<div class="line">rtc_channel_-&gt;enableLocalVideo(type, enable);</div>
<div class="line"><span class="comment">//打开视频辅流</span></div>
<div class="line"><a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">nertc::NERtcVideoStreamType</a> type = <a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a101f9d507d87b67bc5f6da90f336f3fb">nertc::NERtcVideoStreamType::kNERTCVideoStreamSub</a>;</div>
<div class="line"><span class="keywordtype">bool</span> enable = <span class="keyword">true</span>;</div>
<div class="line">rtc_channel_-&gt;enableLocalVideo(type, enable);</div>
<div class="line"><span class="comment">//关闭视频辅流</span></div>
<div class="line"><a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">nertc::NERtcVideoStreamType</a> type = <a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a101f9d507d87b67bc5f6da90f336f3fb">nertc::NERtcVideoStreamType::kNERTCVideoStreamSub</a>;</div>
<div class="line"><span class="keywordtype">bool</span> enable = <span class="keyword">false</span>;</div>
<div class="line">rtc_channel_-&gt;enableLocalVideo(type, enable);</div>
<div class="ttc" id="anamespacenertc_html_a41429a38d9c4e87dad27dcebc0322264"><div class="ttname"><a href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">nertc::NERtcVideoStreamType</a></div><div class="ttdeci">NERtcVideoStreamType</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:5497</div></div>
<div class="ttc" id="anamespacenertc_html_a41429a38d9c4e87dad27dcebc0322264a101f9d507d87b67bc5f6da90f336f3fb"><div class="ttname"><a href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a101f9d507d87b67bc5f6da90f336f3fb">nertc::kNERTCVideoStreamSub</a></div><div class="ttdeci">@ kNERTCVideoStreamSub</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:5515</div></div>
<div class="ttc" id="anamespacenertc_html_a41429a38d9c4e87dad27dcebc0322264a15fcc7ab62484b7ed86661f6e7188a09"><div class="ttname"><a href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a15fcc7ab62484b7ed86661f6e7188a09">nertc::kNERTCVideoStreamMain</a></div><div class="ttdeci">@ kNERTCVideoStreamMain</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:5506</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd><ul>
<li>type 为 kNERTCVideoStreamMain（主流）时：<ul>
<li>开启本地视频采集后，远端会收到 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a0b84dd2fcc3a6f5fe03f36c9cc4911ad">onUserVideoStart</a> 回调。</li>
<li>关闭本地视频采集后，远端会收到 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#ac1dfb8ff38201681140c8ff7e2323bc7">onUserVideoStop</a> 回调。</li>
</ul>
</li>
<li>streamType 为 kNERtcVideoStreamTypeSub（辅流）时：<ul>
<li>开启本地视频采集后，远端会收到 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler_ex.html#a48f88b74beb1db6d8ccbca5f079912ee">onUserSubStreamVideoStart</a> 回调。</li>
<li>关闭本地视频采集后，远端会收到 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler_ex.html#abf09442bb44e42d300bcae8a1b21aaa3">onUserSubStreamVideoStop</a> 回调。 </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30001（kNERtcErrFatal）：通用错误，一般表示引擎错误，尝试再次调用此接口即可。</li>
<li>30005（kNERtcErrInvalidState）：当前状态不支持的操作，比如已开启外部视频采集。</li>
<li>30027（kNERtcErrDeviceOccupied）: 所选设备已被占用。比如已通过主流通道开启了摄像头，无法再通过辅流通道开启摄像头。</li>
<li>50000（kNERtcRuntimeErrVDMNoAuthorize）：应用未获取到操作系统的摄像头权限。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="add4150cf7de0bec23523a216c978245c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4150cf7de0bec23523a216c978245c">&#9670;&nbsp;</a></span>enableMediaPub()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::enableMediaPub </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#ab5f542d6434b5b23b66c82f39be9e8be">NERtcMediaPubType</a>&#160;</td>
          <td class="paramname"><em>media_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>开启或关闭本地媒体流（主流）的发送。 <br  />
该方法用于开始或停止向网络发送本地音频或视频数据。 <br  />
该方法不影响接收或播放远端媒体流，也不会影响本地音频或视频的采集状态。 </p><dl class="section since"><dt>自从</dt><dd>V4.6.10 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>该方法暂时仅支持控制音频流的发送。</li>
<li>该方法在加入房间前后均可调用。</li>
<li>停止发送媒体流的状态会在通话结束后被重置为允许发送。</li>
<li>成功调用该方法切换本地用户的发流状态后，房间内其他用户会收到 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a19d733386e2e6b00ea33cce847112b67">onUserAudioStart</a>（开启发送音频）或 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a000eb885c3743c061f76ce3b03583a3d">onUserAudioStop</a>（停止发送音频）的回调。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>相关接口</dt><dd><ul>
<li><a class="el" href="classnertc_1_1_i_rtc_channel.html#a5d276b222652330d9c88ec6d2f276ea9">muteLocalAudioStream</a>：<ul>
<li>在需要开启本地音频采集（监测本地用户音量）但不发送音频流的情况下，您也可以调用 muteLocalAudioStream(true) 方法。</li>
<li>两者的差异在于， muteLocalAudioStream(true) 仍然保持与服务器的音频通道连接，而 enableMediaPub(false) 表示断开此通道，因此若您的实际业务场景为多人并发的大房间，建议您调用 enableMediaPub 方法。 <br  />
 </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>是否发布本地媒体流。<ul>
<li>true（默认）：发布本地媒体流。</li>
<li>false：不发布本地媒体流。 </li>
</ul>
</td></tr>
    <tr><td class="paramname">media_type</td><td>媒体发布类型，暂时仅支持音频。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0：方法调用成功。</li>
<li>其他：方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5e22a70ba1c0ab41b03c49ea86ba8ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e22a70ba1c0ab41b03c49ea86ba8ad6">&#9670;&nbsp;</a></span>enableSpatializer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::enableSpatializer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>apply_to_team</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>开启或关闭空间音效 </p><dl class="section since"><dt>自从</dt><dd>V5.4.0 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>该接口不支持 Linux 平台 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化后调用此接口，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>开启空间音效后，通话结束时仍保留该开关状态，不重置。 </dd>
<dd>
请先调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#a1f4a30c0749cd8fd82dde57796e86c2b">initSpatializer</a> 接口初始化空间音效算法，再调用本接口。 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>是否打开3D音效算法功能，默认为关闭状态。<ul>
<li>true: 开启空间音效</li>
<li>false: 关闭空间音效 </li>
</ul>
</td></tr>
    <tr><td class="paramname">apply_to_team</td><td>是否仅本小队开启3D音效。<ul>
<li>true: 仅仅和接收端同一个小队的人有3D音效。</li>
<li>false: 接收到所有的语音都有3d音效。 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功</li>
<li>其他: 调用失败 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2c014ecacb3bba8ce64aa62af107af17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c014ecacb3bba8ce64aa62af107af17">&#9670;&nbsp;</a></span>enableSpatializerRoomEffects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::enableSpatializerRoomEffects </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>开启或关闭空间音效的房间混响效果 </p><dl class="section since"><dt>自从</dt><dd>V5.4.0 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>该接口不支持 Linux 平台 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化后调用此接口，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>请先调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#a5e22a70ba1c0ab41b03c49ea86ba8ad6">enableSpatializer</a> 接口启用空间音效，再调用本接口。 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>混响效果开关，默认值关闭 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功</li>
<li>其他: 调用失败 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aacd043b3741351b89cfb1b8635ce6248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd043b3741351b89cfb1b8635ce6248">&#9670;&nbsp;</a></span>getChannelName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* nertc::IRtcChannel::getChannelName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>获取当前房间名。 </p><dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>成功：当前IRtcChannel房间名。</li>
<li>失败：返回空。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a70fe893945782bd2f894df5f02c5bd26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70fe893945782bd2f894df5f02c5bd26">&#9670;&nbsp;</a></span>getConnectionState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacenertc.html#a63c54360dd23ac659013f1e5031bd1d5">NERtcConnectionStateType</a> nertc::IRtcChannel::getConnectionState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>获取当前房间连接状态。 </p><dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="section return"><dt>返回</dt><dd>房间连接状态。::NERtcConnectionStateType. </dd></dl>

</div>
</div>
<a id="a1f4a30c0749cd8fd82dde57796e86c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4a30c0749cd8fd82dde57796e86c2b">&#9670;&nbsp;</a></span>initSpatializer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::initSpatializer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>初始化引擎3D音效算法 </p><dl class="section since"><dt>自从</dt><dd>V5.5.10 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>该接口不支持 Linux 平台 </dd>
<dd>
此接口在加入房间前调用后均可调用。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功</li>
<li>其他: 调用失败 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="acf03b65de2e90983c4d0fdf558bcc5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf03b65de2e90983c4d0fdf558bcc5aa">&#9670;&nbsp;</a></span>joinChannel() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::joinChannel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>加入音视频房间。 <br  />
通过本接口可以实现加入音视频房间，加入房间后可以与房间内的其他用户进行音视频通话。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在初始化后调用该方法。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>加入房间后，同一个房间内的用户可以互相通话，多个用户加入同一个房间，可以群聊。使用不同 App Key 的 App 之间不能互通。</li>
<li>加入音视频房间时，如果指定房间尚未创建，云信 服务器内部会自动创建一个同名房间。</li>
<li>传参中 uid 可选，若不指定则默认为 0，SDK 会自动分配一个随机 uid，并在 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#afca207f68da68817501ad29a28d05128">onJoinChannel</a> 回调方法中返回；App 层必须记住该返回值并维护，SDK 不对该返回值进行维护。</li>
<li>用户成功加入房间后，默认订阅房间内所有其他用户的音频流，可能会因此产生用量并影响计费；若您想取消自动订阅，可以在通话前通过调用 <a class="el" href="classnertc_1_1_i_rtc_engine_ex.html#a4d39a81643f19979461ec0bb569f4a0d">setParameters</a> 方法实现。</li>
<li>网络测速过程中无法加入房间。</li>
<li>若使用了云代理功能，uid 不允许传 0，请用真实的 uid。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>token </td><td>const char </td><td>安全认证签名（NERTC Token），可以设置为：<ul>
<li>
null。调试模式下可设置为 null。安全性不高，建议在产品正式上线前在云信控制台中将鉴权方式恢复为默认的安全模式。</li>
<li>
已获取的 NERTC Token。安全模式下必须设置为获取到的 Token 。若未传入正确的 Token 将无法进入房间。推荐使用安全模式。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line">IRtcChannel *rtc_channel_ = rtc_engine_-&gt;createChannel(secondChannel);</div>
<div class="line">rtc_channel_-&gt;joinChannel(token);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关接口</dt><dd><ul>
<li>您可以调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#ac83171f8a9d2a9f7408fd37c5d64293f">leaveChannel</a> 方法离开房间。</li>
<li>直播场景中，观众角色可以通过 <a class="el" href="classnertc_1_1_i_rtc_engine.html#a827ecfee86c395f564a18012fa919b59">switchChannel</a> 接口切换房间。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>相关回调</dt><dd><ul>
<li>成功调用该方法加入房间后，本地会触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#afca207f68da68817501ad29a28d05128">onJoinChannel</a> 回调，远端会触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a3b402bf80af953058e39d3b69741fb58">onUserJoined</a> 回调。</li>
<li>在弱网环境下，若客户端和服务器失去连接，SDK 会自动重连，并在自动重连成功后触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#ac5e71e5863700c2b91e5078e0c105b73">onRejoinChannel</a> 回调。 </li>
</ul>
</dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30001（kNERtcErrFatal）：重复入会或获取房间信息失败。</li>
<li>30005（kNERtcErrInvalidState)：状态错误，比如引擎尚未初始化或正在进行网络探测。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae5ccb938e986896d1edbaa7eac5504bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ccb938e986896d1edbaa7eac5504bc">&#9670;&nbsp;</a></span>joinChannel() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::joinChannel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a>&#160;</td>
          <td class="paramname"><em>uid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>加入音视频房间。 <br  />
通过本接口可以实现加入音视频房间，加入房间后可以与房间内的其他用户进行音视频通话。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在初始化后调用该方法。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>加入房间后，同一个房间内的用户可以互相通话，多个用户加入同一个房间，可以群聊。使用不同 App Key 的 App 之间不能互通。</li>
<li>加入音视频房间时，如果指定房间尚未创建，云信 服务器内部会自动创建一个同名房间。</li>
<li>传参中 uid 可选，若不指定则默认为 0，SDK 会自动分配一个随机 uid，并在 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#afca207f68da68817501ad29a28d05128">onJoinChannel</a> 回调方法中返回；App 层必须记住该返回值并维护，SDK 不对该返回值进行维护。</li>
<li>用户成功加入房间后，默认订阅房间内所有其他用户的音频流，可能会因此产生用量并影响计费；若您想取消自动订阅，可以在通话前通过调用 <a class="el" href="classnertc_1_1_i_rtc_engine_ex.html#a4d39a81643f19979461ec0bb569f4a0d">setParameters</a> 方法实现。</li>
<li>网络测速过程中无法加入房间。</li>
<li>若使用了云代理功能，uid 不允许传 0，请用真实的 uid。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>token </td><td>const char </td><td>安全认证签名（NERTC Token），可以设置为：<ul>
<li>
null。调试模式下可设置为 null。安全性不高，建议在产品正式上线前在云信控制台中将鉴权方式恢复为默认的安全模式。</li>
<li>
已获取的 NERTC Token。安全模式下必须设置为获取到的 Token 。若未传入正确的 Token 将无法进入房间。推荐使用安全模式。  </li>
</ul>
</td></tr>
<tr>
<td>uid </td><td>uid_t </td><td>user id  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line">IRtcChannel *rtc_channel_ = rtc_engine_-&gt;createChannel(secondChannel);</div>
<div class="line">rtc_channel_-&gt;joinChannel(token, uid);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关接口</dt><dd><ul>
<li>您可以调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#ac83171f8a9d2a9f7408fd37c5d64293f">leaveChannel</a> 方法离开房间。</li>
<li>直播场景中，观众角色可以通过 <a class="el" href="classnertc_1_1_i_rtc_engine.html#a827ecfee86c395f564a18012fa919b59">switchChannel</a> 接口切换房间。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>相关回调</dt><dd><ul>
<li>成功调用该方法加入房间后，本地会触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#afca207f68da68817501ad29a28d05128">onJoinChannel</a> 回调，远端会触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a3b402bf80af953058e39d3b69741fb58">onUserJoined</a> 回调。</li>
<li>在弱网环境下，若客户端和服务器失去连接，SDK 会自动重连，并在自动重连成功后触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#ac5e71e5863700c2b91e5078e0c105b73">onRejoinChannel</a> 回调。 </li>
</ul>
</dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30001（kNERtcErrFatal）：重复入会或获取房间信息失败。</li>
<li>30005（kNERtcErrInvalidState)：状态错误，比如引擎尚未初始化或正在进行网络探测。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7b4a1343dd890e58d4ecea3504f7a6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4a1343dd890e58d4ecea3504f7a6a2">&#9670;&nbsp;</a></span>joinChannel() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::joinChannel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a>&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnertc_1_1_n_e_rtc_join_channel_options.html">NERtcJoinChannelOptions</a>&#160;</td>
          <td class="paramname"><em>channel_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>加入音视频房间。 <br  />
通过本接口可以实现加入音视频房间，加入房间后可以与房间内的其他用户进行音视频通话。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在初始化后调用该方法。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>加入房间后，同一个房间内的用户可以互相通话，多个用户加入同一个房间，可以群聊。使用不同 App Key 的 App 之间不能互通。</li>
<li>加入音视频房间时，如果指定房间尚未创建，云信 服务器内部会自动创建一个同名房间。</li>
<li>传参中 uid 可选，若不指定则默认为 0，SDK 会自动分配一个随机 uid，并在 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#afca207f68da68817501ad29a28d05128">onJoinChannel</a> 回调方法中返回；App 层必须记住该返回值并维护，SDK 不对该返回值进行维护。</li>
<li>用户成功加入房间后，默认订阅房间内所有其他用户的音频流，可能会因此产生用量并影响计费；若您想取消自动订阅，可以在通话前通过调用 <a class="el" href="classnertc_1_1_i_rtc_engine_ex.html#a4d39a81643f19979461ec0bb569f4a0d">setParameters</a> 方法实现。</li>
<li>网络测速过程中无法加入房间。</li>
<li>若使用了云代理功能，uid 不允许传 0，请用真实的 uid。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>token </td><td>const char </td><td>安全认证签名（NERTC Token），可以设置为：<ul>
<li>
null。调试模式下可设置为 null。安全性不高，建议在产品正式上线前在云信控制台中将鉴权方式恢复为默认的安全模式。</li>
<li>
已获取的 NERTC Token。安全模式下必须设置为获取到的 Token 。若未传入正确的 Token 将无法进入房间。推荐使用安全模式。  </li>
</ul>
</td></tr>
<tr>
<td>channel_options </td><td><a class="el" href="structnertc_1_1_n_e_rtc_join_channel_options.html">NERtcJoinChannelOptions</a> </td><td>加入房间时设置一些特定的房间参数。默认值为 nil。  </td></tr>
<tr>
<td>uid </td><td>uid_t </td><td>user id  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line">IRtcChannel *rtc_channel_ = rtc_engine_-&gt;createChannel(secondChannel);</div>
<div class="line">NERtcJoinChannelOptions channel_options;</div>
<div class="line">strcpy(channel_options.custom_info, <span class="stringliteral">&quot;custom info&quot;</span>);</div>
<div class="line">channel_options.permission_key = <span class="stringliteral">&quot;permission key&quot;</span>;</div>
<div class="line">rtc_channel_-&gt;joinChannel(token, uid, channel_options);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关接口</dt><dd><ul>
<li>您可以调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#ac83171f8a9d2a9f7408fd37c5d64293f">leaveChannel</a> 方法离开房间。</li>
<li>直播场景中，观众角色可以通过 <a class="el" href="classnertc_1_1_i_rtc_engine.html#a827ecfee86c395f564a18012fa919b59">switchChannel</a> 接口切换房间。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>相关回调</dt><dd><ul>
<li>成功调用该方法加入房间后，本地会触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#afca207f68da68817501ad29a28d05128">onJoinChannel</a> 回调，远端会触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a3b402bf80af953058e39d3b69741fb58">onUserJoined</a> 回调。</li>
<li>在弱网环境下，若客户端和服务器失去连接，SDK 会自动重连，并在自动重连成功后触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#ac5e71e5863700c2b91e5078e0c105b73">onRejoinChannel</a> 回调。 </li>
</ul>
</dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30001（kNERtcErrFatal）：重复入会或获取房间信息失败。</li>
<li>30005（kNERtcErrInvalidState)：状态错误，比如引擎尚未初始化或正在进行网络探测。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac83171f8a9d2a9f7408fd37c5d64293f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83171f8a9d2a9f7408fd37c5d64293f">&#9670;&nbsp;</a></span>leaveChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::leaveChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>离开音视频房间。 <br  />
通过本接口可以实现挂断或退出通话，并释放本房间内的相关资源。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在初始化并成功加入房间后调用该方法。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>结束通话时必须调用此方法离开房间，否则无法开始下一次通话。</li>
<li>该方法是异步操作，调用返回时并没有真正退出频道。在真正退出房间后，SDK 会触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a4b4f0be8008fced099e8173d0170179b">onLeaveChannel</a> 回调。</li>
<li>如果在调用 leaveChannel 后立即调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#ad809d26d54f150df8dad8a4e51b8d79a">release</a> 方法，可能会无法正常离开房间；建议您在收到 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a4b4f0be8008fced099e8173d0170179b">onLeaveChannel</a> 回调之后再调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#ad809d26d54f150df8dad8a4e51b8d79a">release</a> 方法释放会话相关所有资源。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line">rtc_channel_-&gt;leaveChannel();</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd>成功调用该方法离开房间后，本地会触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a4b4f0be8008fced099e8173d0170179b">onLeaveChannel</a> 回调，远端会触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#aeafb2c99e30fd6f2766ab23d4edee788">onUserLeft</a> 回调。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30001（kNERtcErrFatal）：正在进行网络探测。</li>
<li>30005（kNERtcErrInvalidState)：状态错误，比如引擎尚未初始化。</li>
<li>30101（kNERtcErrChannelNotJoined）：尚未加入房间。</li>
<li>30102（kNERtcErrChannelRepleatedlyLeave）：重复离开房间。</li>
<li>30104（kNERtcErrSessionNotFound）：会话未找到。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5d276b222652330d9c88ec6d2f276ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d276b222652330d9c88ec6d2f276ea9">&#9670;&nbsp;</a></span>muteLocalAudioStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::muteLocalAudioStream </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mute</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>开启或关闭本地音频主流的发送。 <br  />
该方法用于向网络发送或取消发送本地音频数据，不影响本地音频的采集状态，也不影响接收或播放远端音频流。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化之后调用此接口，且该方法仅可在加入房间后调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>该方法设置内部引擎为启用状态，在 <a class="el" href="classnertc_1_1_i_rtc_channel.html#ac83171f8a9d2a9f7408fd37c5d64293f">leaveChannel</a> 后恢复至默认（非静音）。 </dd></dl>
<dl class="section user"><dt>参数说明 </dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>mute </td><td>bool </td><td>是否关闭本地音频的发送：<ul>
<li>
true：不发送本地音频。</li>
<li>
false：发送本地音频。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//不发送本地音频</span></div>
<div class="line">rtc_channel_-&gt;muteLocalAudioStream(<span class="keyword">false</span>);</div>
<div class="line"><span class="comment">//发送本地音频</span></div>
<div class="line">rtc_channel_-&gt;muteLocalAudioStream(<span class="keyword">true</span>);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd>若本地用户在说话，成功调用该方法后，房间内其他用户会收到 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#aedb90407d4da4a776b51c44c571ee18a">onUserAudioMute</a> 回调。 </dd></dl>
<dl class="section user"><dt>相关接口</dt><dd><a class="el" href="classnertc_1_1_i_rtc_channel.html#add4150cf7de0bec23523a216c978245c">enableMediaPub</a>：<ul>
<li>在需要开启本地音频采集（监测本地用户音量）但不发送音频流的情况下，您也可以调用 enableMeidaPub(false) 方法。</li>
<li>两者的差异在于，muteLocalAudioStream(true) 仍然保持与服务器的音频通道连接，而 enableMediaPub(false) 表示断开此通道，因此若您的实际业务场景为多人并发的大房间，建议您调用 enableMediaPub 方法。 <br  />
 </li>
</ul>
</dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30005（kNERtcErrInvalidState）：引擎未初始化。</li>
<li>30107（kNERtcErrMediaNotStarted）：媒体会话未建立，比如对端未开启音频流。</li>
<li>30200（kNERtcErrConnectionNotFound）: 连接未建立。</li>
<li>30203（kNERtcErrTrackNotFound）：音频 track 未找到。</li>
<li>30300：Transceiver 未找到。</li>
<li>30400：未找到对应房间。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7ff5640cea90d89b00d2403d5c09c45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff5640cea90d89b00d2403d5c09c45d">&#9670;&nbsp;</a></span>muteLocalSubStreamAudio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::muteLocalSubStreamAudio </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mute</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>静音或解除静音本地上行的音频辅流。 </p><dl class="section note"><dt>注解</dt><dd><ul>
<li>该方法仅可在加入房间后调用。</li>
<li>静音状态会在通话结束后被重置为非静音。 </li>
</ul>
</dd></dl>
<dl class="section since"><dt>自从</dt><dd>V4.6.10 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mute</td><td>是否静音本地音频辅流发送。<ul>
<li>true（默认）：静音本地音频辅流。</li>
<li>false: 取消静音本地音频辅流。 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0：方法调用成功。</li>
<li>其他：方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a07092693bb41ff97f5c376d2b3700ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07092693bb41ff97f5c376d2b3700ed1">&#9670;&nbsp;</a></span>muteLocalVideoStream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::muteLocalVideoStream </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mute</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>取消或恢复发布本端视频主流。 <br  />
调用该方法取消发布本地视频主流后，SDK 不再发送本地视频主流。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>使用前提 </dt><dd>一般在通过 <a class="el" href="classnertc_1_1_i_rtc_channel.html#aba1054b2bb49c402013b62faf170bd2c">enableLocalVideo</a> (true) 接口开启本地视频采集并发送后调用该方法。 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在初始化后调用该方法，且该方法仅可在加入房间后调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>纯音频 SDK 禁用该接口，如需使用请前往<a href="https://doc.yunxin.163.com/nertc/sdk-download" target="_blank">云信官网</a>下载并替换成视频 SDK。</li>
<li>调用该方法取消发布本地视频流时，设备仍然处于工作状态。</li>
<li>该方法设置内部引擎为启用状态，在 <a class="el" href="classnertc_1_1_i_rtc_channel.html#ac83171f8a9d2a9f7408fd37c5d64293f">nertc::IRtcChannel::leaveChannel</a> "leaveChannel" 后设置失效，将恢复至默认，即默认发布本地视频流。</li>
<li>该方法与 <a class="el" href="classnertc_1_1_i_rtc_channel.html#a5c336b19e3c9b0db9a73b9515d7108d7">enableLocalVideo</a> (false) 的区别在于，后者会关闭本地摄像头设备，该方法不禁用摄像头，不会影响本地视频流采集且响应速度更快。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>mute </td><td>bool </td><td>是否取消发布本地视频流：<ul>
<li>
true：取消发布本地视频流。</li>
<li>
false：恢复发布本地视频流。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="keywordflow">if</span> (rtc_channel_) {</div>
<div class="line"><span class="keywordtype">int</span> res = rtc_channel_-&gt;muteLocalVideoStream(<span class="keyword">true</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd>取消发布本地视频主流或辅流后，远端会收到 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#ad05d02f91cc2d4dd8f640b015bea7315">onUserVideoMute</a> 回调。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30004（kNERtcErrNotSupported）：不支持的操作，比如纯音频 SDK 不支持该功能。</li>
<li>30005（kNERtcErrInvalidState）：当前状态不支持的操作，比如引擎尚未初始化。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a65a9d4a89d7d81419a1638af0a7e0be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a9d4a89d7d81419a1638af0a7e0be3">&#9670;&nbsp;</a></span>muteLocalVideoStream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::muteLocalVideoStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mute</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>取消或恢复发布本地视频。 <br  />
调用该方法取消发布本地视频主流或辅流后，SDK 不再发送本地视频流。 </p><dl class="section since"><dt>自从</dt><dd>V4.6.20 </dd></dl>
<dl class="section user"><dt>使用前提 </dt><dd>一般在通过 <a class="el" href="classnertc_1_1_i_rtc_channel.html#aba1054b2bb49c402013b62faf170bd2c">enableLocalVideo</a> (true) 接口开启本地视频采集并发送后调用该方法。 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在初始化后调用该方法，且该方法仅可在加入房间后调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>纯音频 SDK 禁用该接口，如需使用请前往<a href="https://doc.yunxin.163.com/nertc/sdk-download" target="_blank">云信官网</a>下载并替换成视频 SDK。</li>
<li>调用该方法取消发布本地视频流时，设备仍然处于工作状态。</li>
<li>若调用该方法取消发布本地视频流，通话结束后会被重置为默认状态，即默认发布本地视频流。</li>
<li>该方法与 <a class="el" href="classnertc_1_1_i_rtc_channel.html#aba1054b2bb49c402013b62faf170bd2c">enableLocalVideo</a> (false) 的区别在于，后者会关闭本地摄像头设备，该方法不禁用摄像头，不会影响本地视频流采集且响应速度更快。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>type </td><td><a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a> </td><td>视频通道类型：<ul>
<li>
kNERTCVideoStreamMain：主流。</li>
<li>
kNERTCVideoStreamSub：辅流。  </li>
</ul>
</td></tr>
<tr>
<td>mute </td><td>bool </td><td>是否取消发布本地视频流：<ul>
<li>
true：取消发布本地视频流。</li>
<li>
false：恢复发布本地视频流。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//取消发布本地视频主流</span></div>
<div class="line"><a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">nertc::NERtcVideoStreamType</a> type = <a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a15fcc7ab62484b7ed86661f6e7188a09">nertc::NERtcVideoStreamType::kNERTCVideoStreamMain</a>;</div>
<div class="line"><span class="keywordtype">bool</span> mute = <span class="keyword">true</span>;</div>
<div class="line">rtc_channel_-&gt;muteLocalVideoStream(type, mute);</div>
<div class="line"><span class="comment">//恢复发布本地视频主流</span></div>
<div class="line"><a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">nertc::NERtcVideoStreamType</a> type = <a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a15fcc7ab62484b7ed86661f6e7188a09">nertc::NERtcVideoStreamType::kNERTCVideoStreamMain</a>;</div>
<div class="line"><span class="keywordtype">bool</span> mute = <span class="keyword">false</span>;</div>
<div class="line">rtc_channel_-&gt;muteLocalVideoStream(type, mute);</div>
<div class="line"><span class="comment">//取消发布本地视频辅流</span></div>
<div class="line"><a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">nertc::NERtcVideoStreamType</a> type = <a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a101f9d507d87b67bc5f6da90f336f3fb">nertc::NERtcVideoStreamType::kNERTCVideoStreamSub</a>;</div>
<div class="line"><span class="keywordtype">bool</span> mute = <span class="keyword">true</span>;</div>
<div class="line">rtc_channel_-&gt;muteLocalVideoStream(type, mute);</div>
<div class="line"><span class="comment">//恢复发布本地视频辅流</span></div>
<div class="line"><a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">nertc::NERtcVideoStreamType</a> type = <a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a101f9d507d87b67bc5f6da90f336f3fb">nertc::NERtcVideoStreamType::kNERTCVideoStreamSub</a>;</div>
<div class="line"><span class="keywordtype">bool</span> mute = <span class="keyword">false</span>;</div>
<div class="line">rtc_channel_-&gt;muteLocalVideoStream(type, mute);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd>取消发布本地视频主流或辅流后，远端会收到 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler_ex.html#ac7e5ac9ae38cd3299cc71a73e17f42ac">onUserVideoMute</a> 回调。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8c41396be7946df550e546043334a782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c41396be7946df550e546043334a782">&#9670;&nbsp;</a></span>pauseScreenCapture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::pauseScreenCapture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>暂停屏幕共享。</p><ul>
<li>暂停屏幕共享后，共享区域内会持续显示暂停前的最后一帧画面，直至通过 resumeScreenCapture 恢复屏幕共享。</li>
<li>在 Windows 平台中，本端会触发 onScreenCaptureStatus 回调。 </li>
</ul>
<dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功</li>
<li>其他: 方法调用失败 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a32bd589253324487fddc327cbd298a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bd589253324487fddc327cbd298a7a">&#9670;&nbsp;</a></span>pushExternalVideoFrame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::pushExternalVideoFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnertc_1_1_n_e_rtc_video_frame.html">NERtcVideoFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>推送外部视频帧。 <br  />
该方法主动将视频帧数据用 <a class="el" href="structnertc_1_1_n_e_rtc_video_frame.html">NERtcVideoFrame</a> 类封装后传递给 SDK。 请确保在你调用本方法前已调用 setExternalVideoSource，并将参数设为 true，否则调用本方法后会一直报错。 </p><dl class="section note"><dt>注解</dt><dd>该方法设置内部引擎为启用状态，在 <a class="el" href="classnertc_1_1_i_rtc_engine.html#a6fbc54a71986a4a4a1c9c24d2c29e884">leaveChannel</a> 后不再有效。 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>外部视频帧数据。详细信息请参考 <a class="el" href="structnertc_1_1_n_e_rtc_video_frame.html">NERtcVideoFrame</a> 。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功；</li>
<li>其他: 方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae42bc7c15dab5ecaf4d911afde595b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42bc7c15dab5ecaf4d911afde595b18">&#9670;&nbsp;</a></span>pushExternalVideoFrame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::pushExternalVideoFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnertc_1_1_n_e_rtc_video_frame.html">NERtcVideoFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>推送外部视频帧。 <br  />
该方法主动将视频帧数据用 <a class="el" href="structnertc_1_1_n_e_rtc_video_frame.html">NERtcVideoFrame</a> 类封装后传递给 SDK。 请确保在你调用本方法前已调用 setExternalVideoSource，并将参数设为 true，否则调用本方法后会一直报错。 </p><dl class="section note"><dt>注解</dt><dd>该方法设置内部引擎为启用状态，在 <a class="el" href="classnertc_1_1_i_rtc_engine.html#a6fbc54a71986a4a4a1c9c24d2c29e884">leaveChannel</a> 后不再有效。 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>视频帧数据。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功；</li>
<li>其他: 方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad809d26d54f150df8dad8a4e51b8d79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad809d26d54f150df8dad8a4e51b8d79a">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nertc::IRtcChannel::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>销毁 <a class="el" href="classnertc_1_1_i_rtc_channel.html">IRtcChannel</a> 实例，释放资源。 </p><dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>

</div>
</div>
<a id="af1f7f8aeed2c95bb5852e8a8b0cf9232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f7f8aeed2c95bb5852e8a8b0cf9232">&#9670;&nbsp;</a></span>removeLiveStreamTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::removeLiveStreamTask </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>task_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>删除房间内指定推流任务。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>使用前提</dt><dd>请先调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#a3fd04f5c8c7733bc661ba32137e978e9">addLiveStreamTask</a> 方法添加推流任务。 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化之后调用此接口，且该方法仅可在加入房间后调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>仅角色为主播的房间成员能调用此接口，观众成员无相关推流权限。</li>
<li>通话结束，房间成员全部离开房间后，推流任务会自动删除；如果房间内还有用户存在，则需要创建推流任务的用户删除推流任务。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>task_id </td><td>const char* </td><td>推流任务 ID。  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="keywordflow">if</span> (rtc_channel_) {</div>
<div class="line">    <span class="keywordflow">return</span> rtc_channel_-&gt;removeLiveStreamTask(task_id);</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd><a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a8fac9cdf54d35089921c74a6ec91b4d7">onRemoveLiveStreamTask</a>：推流任务已成功删除回调。 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a16bf1ed05a44102458c587bc59cb140f">onLiveStreamState</a>：推流任务状态已改变回调。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功；</li>
<li>其他：方法调用失败。<ul>
<li>403（kNERtcErrChannelReservePermissionDenied）：权限不足，观众模式下不支持此操作。</li>
<li>30005（kNERtcErrChannelNotJoined）：状态错误，比如引擎尚未初始化。</li>
<li>30101（kNERtcErrChannelNotJoined）：尚未加入房间。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="aea86f48b384d6a7a6cf53b945b00324c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea86f48b384d6a7a6cf53b945b00324c">&#9670;&nbsp;</a></span>reportCustomEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::reportCustomEvent </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>event_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>custom_identify</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>上报自定义事件 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_name</td><td>事件名 不能为空 </td></tr>
    <tr><td class="paramname">custom_identify</td><td>自定义标识，比如产品或业务类型，如不需要填null </td></tr>
    <tr><td class="paramname">parameters</td><td>参数键值对 ，参数值支持String 及java基本类型(int 、bool....) ， 如不需要填null </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>操作返回值，成功则返回 0 </dd></dl>

</div>
</div>
<a id="a17d15807d86187d0417632bc83aa7fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d15807d86187d0417632bc83aa7fb9">&#9670;&nbsp;</a></span>resumeScreenCapture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::resumeScreenCapture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>恢复屏幕共享。 <br  />
在 Windows 平台中，远端会触发 onScreenCaptureStatus 回调。 </p><dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功</li>
<li>其他: 方法调用失败 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a170f18f35a304f2191af9463b9e13277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170f18f35a304f2191af9463b9e13277">&#9670;&nbsp;</a></span>sendSEIMsg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::sendSEIMsg </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>发送媒体补充增强信息（SEI）。 在本端推流传输视频流数据同时，发送流媒体补充增强信息来同步一些其他附加信息。当推流方发送 SEI 后，拉流方可通过监听 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler_ex.html#a7ae085dd56871d5f27abc6498c02d6ac">IRtcEngineEventHandlerEx::onRecvSEIMsg</a> 的回调获取 SEI 内容。</p><ul>
<li>调用时机：视频流（主流）开启后，可调用此函数。</li>
<li>数据长度限制： SEI 最大数据长度为 4096 字节，超限会发送失败。如果频繁发送大量数据会导致视频码率增大，可能会导致视频画质下降甚至卡顿。</li>
<li>发送频率限制：最高为视频发送的帧率，建议不超过 10 次/秒。</li>
<li>生效时间：调用本接口之后，最快在下一帧视频数据帧之后发送 SEI 数据，最慢在接下来的 5 帧视频之后发送。 </li>
</ul>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>SEI 数据跟随视频帧发送，由于在弱网环境下可能丢帧，SEI 数据也可能随之丢失，所以建议在发送频率限制之内多次发送，保证接收端收到的概率。</li>
<li>调用本接口时，默认使用主流通道发送 SEI。 </li>
</ul>
</dd></dl>
<dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>自定义 SEI 数据。 </td></tr>
    <tr><td class="paramname">length</td><td>自定义 SEI 数据长度，最大不超过 4096 字节。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>纯音频SDK禁用该接口，如需使用请前往云信官网下载并替换成视频SDK </dd></dl>
<dl class="section return"><dt>返回</dt><dd>操作返回值，成功则返回 0<ul>
<li>成功: 成功进入待发送队列，会在最近的视频帧之后发送该数据</li>
<li>失败: 数据被限制发送，可能发送的频率太高，队列已经满了，或者数据大小超过最大值 4k </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a30d0ebc2b2de0d3f92c4eda5fcc756dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d0ebc2b2de0d3f92c4eda5fcc756dc">&#9670;&nbsp;</a></span>sendSEIMsg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::sendSEIMsg </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>发送媒体补充增强信息（SEI）。 <br  />
在本端推流传输视频流数据同时，发送流媒体补充增强信息来同步一些其他附加信息。当推流方发送 SEI 后，拉流方可通过监听 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler_ex.html#a7ae085dd56871d5f27abc6498c02d6ac">IRtcEngineEventHandlerEx::onRecvSEIMsg</a> 的回调获取 SEI 内容。</p><ul>
<li>调用时机：视频流（主流）开启后，可调用此函数。</li>
<li>数据长度限制： SEI 最大数据长度为 4096 字节，超限会发送失败。如果频繁发送大量数据会导致视频码率增大，可能会导致视频画质下降甚至卡顿。</li>
<li>发送频率限制：最高为视频发送的帧率，建议不超过 10 次/秒。</li>
<li>生效时间：调用本接口之后，最快在下一帧视频数据帧之后发送 SEI 数据，最慢在接下来的 5 帧视频之后发送。 </li>
</ul>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>SEI 数据跟随视频帧发送，由于在弱网环境下可能丢帧，SEI 数据也可能随之丢失，所以建议在发送频率限制之内多次发送，保证接收端收到的概率。</li>
<li>调用本接口时，默认使用主流通道发送 SEI。 </li>
</ul>
</dd></dl>
<dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>自定义 SEI 数据。 </td></tr>
    <tr><td class="paramname">length</td><td>自定义 SEI 数据长度，最大不超过 4096 字节。 </td></tr>
    <tr><td class="paramname">type</td><td>发送 SEI 时，使用的流通道类型。详细信息请参考 <a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a> 。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>操作返回值，成功则返回 0<ul>
<li>成功: 成功进入待发送队列，会在最近的视频帧之后发送该数据</li>
<li>失败: 数据被限制发送，可能发送的频率太高，队列已经满了，或者数据大小超过最大值 4k </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac0317f9c66afe19ebd7718be42442790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0317f9c66afe19ebd7718be42442790">&#9670;&nbsp;</a></span>setAudioRecvRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setAudioRecvRange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>audible_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>conversational_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#aed5324bd7a40767f0f2c6ae857fa9e2c">NERtcDistanceRolloffModel</a>&#160;</td>
          <td class="paramname"><em>roll_off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>距离范围设置 </p><dl class="section since"><dt>自从</dt><dd>V5.5.10 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>此接口在加入房间前后均可调用</li>
<li>若要使用范围语音或3D音效功能需要入会前调用一次</li>
<li>仅使用范围语音时，通过设置audible_distance设置语音接收范围，其他参数设置不生效，填写默认值即可。 </li>
</ul>
</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">audible_distance</td><td>监听器能够听到扬声器并接收其语音的距离扬声器的最大距离。距离有效范围：[1,max int) ，无默认值。 </td></tr>
    <tr><td class="paramname">conversational_distance</td><td>控制音频保持其原始音量的范围，超出该范围时，语音聊天的响度在被听到时开始淡出。 默认值为 1。 </td></tr>
    <tr><td class="paramname">roll_off:距离衰减模式</td><td><a class="el" href="namespacenertc.html#aed5324bd7a40767f0f2c6ae857fa9e2c">NERtcDistanceRolloffModel</a> ，默认值 <a class="el" href="namespacenertc.html#aed5324bd7a40767f0f2c6ae857fa9e2caa1730ad61bf663980202c7fda6c917f9">kNERtcDistanceRolloffNone</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功</li>
<li>其他: 调用失败 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a97fb83d15f988140d47e9217b427104c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97fb83d15f988140d47e9217b427104c">&#9670;&nbsp;</a></span>setAudioSubscribeOnlyBy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setAudioSubscribeOnlyBy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> *&#160;</td>
          <td class="paramname"><em>uid_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置自己的音频只能被房间内指定的人订阅。 <br  />
默认房间所有其他人都可以订阅自己的音频。 </p><dl class="section note"><dt>注解</dt><dd><ul>
<li>此接口需要在加入房间成功后调用。</li>
<li>对于调用接口时不在房间的 uid 不生效。 </li>
</ul>
</dd></dl>
<dl class="section since"><dt>自从</dt><dd>V4.6.10 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uid_array</td><td>可订阅自己音频的用户uid 列表。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>此列表为全量列表。如果列表为空或 null，表示其他所有人均可订阅自己的音频。 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>uid_array 的数组长度。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0：方法调用成功。</li>
<li>其他：方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae5ec83d0bff16e3148c141bd1f6a2abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ec83d0bff16e3148c141bd1f6a2abb">&#9670;&nbsp;</a></span>setCameraCaptureConfig() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setCameraCaptureConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnertc_1_1_n_e_rtc_camera_capture_config.html">NERtcCameraCaptureConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置本地摄像头的视频主流采集配置。 <br  />
通过此接口可以设置本地摄像头采集的主流视频宽度、高度、旋转角度等。 </p><dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="section user"><dt>调用时机 </dt><dd>请在初始化后调用该方法，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section user"><dt>业务场景</dt><dd>在视频通话或直播中，SDK 自动控制摄像头的输出参数。默认情况下，SDK 会根据用户该接口的配置匹配最合适的分辨率进行采集。但是在部分业务场景中，如果采集画面质量无法满足实际需求，可以调用该接口调整摄像头的采集配置。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>纯音频 SDK 禁用该接口，如需使用请前往<a href="https://doc.yunxin.163.com/nertc/sdk-download" target="_blank">云信官网</a>下载并替换成视频 SDK。</li>
<li>该方法仅适用于视频主流，若您希望为辅流通道设置摄像头的采集配置，请调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#a70cebba9bb1f98aa8ab14e89ab0cd742">nertc::IRtcChannel::setCameraCaptureConfig(NERtcVideoStreamType type, const NERtcCameraCaptureConfig&amp; config)</a>} "setCameraCaptureConfig" 方法。</li>
<li>该方法支持在加入房间后动态调用，设置成功后，会自动重启摄像头采集模块。</li>
<li>若系统相机不支持您设置的分辨率，会自动调整为最相近一档的分辨率，因此建议您设置为常规标准的分辨率。</li>
<li>设置较高的采集分辨率会增加性能消耗，例如 CPU 和内存占用等，尤其是在开启视频前处理的场景下。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>captureConfig </td><td><a class="el" href="structnertc_1_1_n_e_rtc_camera_capture_config.html">NERtcCameraCaptureConfig</a> </td><td>本地摄像头采集配置。  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><a class="code" href="structnertc_1_1_n_e_rtc_camera_capture_config.html">nertc::NERtcCameraCaptureConfig</a> capture_config;</div>
<div class="line">capture_config.<a class="code" href="structnertc_1_1_n_e_rtc_camera_capture_config.html#afc3e7953b9f63e440073f21cd5c58809">captureWidth</a> = w;</div>
<div class="line">capture_config.<a class="code" href="structnertc_1_1_n_e_rtc_camera_capture_config.html#a61a44f44f80803e14a650c376d8adeb5">captureHeight</a> = h;</div>
<div class="line"><span class="keywordflow">if</span> (rtc_channel_) {</div>
<div class="line">    rtc_channel_-&gt;setCameraCaptureConfig(capture_config);</div>
<div class="line">}</div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_camera_capture_config_html"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_camera_capture_config.html">nertc::NERtcCameraCaptureConfig</a></div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:1572</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_camera_capture_config_html_a61a44f44f80803e14a650c376d8adeb5"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_camera_capture_config.html#a61a44f44f80803e14a650c376d8adeb5">nertc::NERtcCameraCaptureConfig::captureHeight</a></div><div class="ttdeci">int captureHeight</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:1618</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_camera_capture_config_html_afc3e7953b9f63e440073f21cd5c58809"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_camera_capture_config.html#afc3e7953b9f63e440073f21cd5c58809">nertc::NERtcCameraCaptureConfig::captureWidth</a></div><div class="ttdeci">int captureWidth</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:1595</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30004（kNERtcErrNotSupported）：不支持的操作，比如当前使用的是纯音频 SDK。</li>
<li>30005（kNERtcErrInvalidState）：当前状态不支持的操作，比如引擎未初始化成功。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a70cebba9bb1f98aa8ab14e89ab0cd742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70cebba9bb1f98aa8ab14e89ab0cd742">&#9670;&nbsp;</a></span>setCameraCaptureConfig() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setCameraCaptureConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnertc_1_1_n_e_rtc_camera_capture_config.html">NERtcCameraCaptureConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置本地摄像头的视频主流或辅流采集配置。 <br  />
通过此接口可以设置本地摄像头采集的主流或辅流视频宽度、高度、旋转角度等。 </p><dl class="section since"><dt>自从</dt><dd>V4.6.20 </dd></dl>
<dl class="section user"><dt>调用时机 </dt><dd>请在初始化后调用该方法，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section user"><dt>业务场景</dt><dd>在视频通话或直播中，SDK 自动控制摄像头的输出参数。默认情况下，SDK 会根据用户该接口的配置匹配最合适的分辨率进行采集。但是在部分业务场景中，如果采集画面质量无法满足实际需求，可以调用该接口调整摄像头的采集配置。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>纯音频 SDK 禁用该接口，如需使用请前往<a href="https://doc.yunxin.163.com/nertc/sdk-download" target="_blank">云信官网</a>下载并替换成视频 SDK。</li>
<li>调用该接口设置成功后，会自动重启摄像头采集模块。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>type </td><td><a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a> </td><td>视频通道类型：<ul>
<li>
kNERtcVideoStreamMain：主流。</li>
<li>
kNERtcVideoStreamSub：辅流。  </li>
</ul>
</td></tr>
<tr>
<td>captureConfig </td><td><a class="el" href="structnertc_1_1_n_e_rtc_camera_capture_config.html">NERtcCameraCaptureConfig</a> </td><td>本地摄像头采集配置。  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//设置本地摄像头主流采集配置</span></div>
<div class="line"><a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">nertc::NERtcVideoStreamType</a> type = <a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a15fcc7ab62484b7ed86661f6e7188a09">nertc::NERtcVideoStreamType::kNERTCVideoStreamMain</a>;</div>
<div class="line"><a class="code" href="structnertc_1_1_n_e_rtc_video_config.html">nertc::NERtcVideoConfig</a> video_config_ = {};</div>
<div class="line">video_config_.captureWidth = 1920; <span class="comment">// 编码分辨率的宽</span></div>
<div class="line">video_config_.captureHeight = 1080; <span class="comment">// 编码分辨率的高</span></div>
<div class="line">rtc_channel_-&gt;setCameraCaptureConfig(type, video_config_);</div>
<div class="line"><span class="comment">//设置本地摄像头辅流采集配置</span></div>
<div class="line"><a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">nertc::NERtcVideoStreamType</a> type = <a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a101f9d507d87b67bc5f6da90f336f3fb">nertc::NERtcVideoStreamType::kNERTCVideoStreamSub</a>;</div>
<div class="line"><a class="code" href="structnertc_1_1_n_e_rtc_video_config.html">nertc::NERtcVideoConfig</a> video_config_ = {};</div>
<div class="line">video_config_.captureWidth = 1920; <span class="comment">// 编码分辨率的宽</span></div>
<div class="line">video_config_.captureHeight = 1080; <span class="comment">// 编码分辨率的高</span></div>
<div class="line">rtc_channel_-&gt;setCameraCaptureConfig(type, video_config_);</div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_config_html"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_config.html">nertc::NERtcVideoConfig</a></div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:3589</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a07f0853ba865a0d0568d0223b8a01b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f0853ba865a0d0568d0223b8a01b84">&#9670;&nbsp;</a></span>setChannelEventHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setChannelEventHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html">IRtcChannelEventHandler</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置 <a class="el" href="classnertc_1_1_i_rtc_channel.html">IRtcChannel</a> 对象的事件句柄。 <br  />
你可以通过设置的事件句柄，监听当前IRtcChannel对象对应房间的事件，并接收房间中用户视频信息等。 </p><dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>事件监听句柄对象 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功；</li>
<li>其他: 方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a12b612e14b04eb8fc61b31484d536509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b612e14b04eb8fc61b31484d536509">&#9670;&nbsp;</a></span>setClientRole()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setClientRole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a1277b5498334b7efe3ad260d72350128">NERtcClientRole</a>&#160;</td>
          <td class="paramname"><em>role</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置直播场景下的用户角色。 <br  />
通过本接口可以实现将用户角色在“主播”（kNERtcClientRoleBroadcaster）和“观众“（kNERtcClientRoleAudience）之间的切换，用户加入房间后默认为“主播”。 </p><dl class="section since"><dt>自从</dt><dd>V3.9.0 </dd></dl>
<dl class="section user"><dt>使用前提</dt><dd>该方法仅在通过 <a class="el" href="classnertc_1_1_i_rtc_engine.html#a6195db00acf739ca2cb183015abffd5b">setChannelProfile</a> 方法设置房间场景为直播场景（kNERtcChannelProfileLiveBroadcasting）时调用有效。 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在初始化后调用该方法，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section user"><dt>业务场景</dt><dd>适用于观众上下麦与主播互动的互动直播场景。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>用户切换为观众角色时，SDK 会自动关闭音视频设备。 </dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>role </td><td><a class="el" href="namespacenertc.html#a1277b5498334b7efe3ad260d72350128">NERtcClientRole</a>  </td><td>用户角色：<ul>
<li>
kNERtcClientRoleBroadcaster（0）：设置用户角色为主播。主播可以开关摄像头等设备、可以发布流、可以操作互动直播推流相关接口、加入或退出房间状态对其他房间内用户可见。</li>
<li>
kNERtcClientRoleAudience（1）：设置用户角色为观众。观众只能收流不能发流加入或退出房间状态对其他房间内用户不可见。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//切换用户角色为主播</span></div>
<div class="line">rtc_channel_-&gt;setClientRole(<a class="code" href="namespacenertc.html#a1277b5498334b7efe3ad260d72350128ac92856d4ac2f538c1ad8bac9c6f578d7">nertc::kNERtcClientRoleBroadcaster</a>);</div>
<div class="line"><span class="comment">//切换用户角色为观众</span></div>
<div class="line">rtc_channel_-&gt;setClientRole(<a class="code" href="namespacenertc.html#a1277b5498334b7efe3ad260d72350128ac5a941fda770423acd9f7471071e7aef">nertc::kNERtcClientRoleAudience</a>);</div>
<div class="ttc" id="anamespacenertc_html_a1277b5498334b7efe3ad260d72350128ac5a941fda770423acd9f7471071e7aef"><div class="ttname"><a href="namespacenertc.html#a1277b5498334b7efe3ad260d72350128ac5a941fda770423acd9f7471071e7aef">nertc::kNERtcClientRoleAudience</a></div><div class="ttdeci">@ kNERtcClientRoleAudience</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:266</div></div>
<div class="ttc" id="anamespacenertc_html_a1277b5498334b7efe3ad260d72350128ac92856d4ac2f538c1ad8bac9c6f578d7"><div class="ttname"><a href="namespacenertc.html#a1277b5498334b7efe3ad260d72350128ac92856d4ac2f538c1ad8bac9c6f578d7">nertc::kNERtcClientRoleBroadcaster</a></div><div class="ttdeci">@ kNERtcClientRoleBroadcaster</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:255</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd><ul>
<li>加入房间前调用该方法设置用户角色，不会触发任何回调，在加入房间成功后角色自动生效：<ul>
<li>设置用户角色为主播：加入房间后，远端用户触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a3b402bf80af953058e39d3b69741fb58">onUserJoined</a> 回调。</li>
<li>设置用户角色为观众：加入房间后，远端用户不触发任何回调。</li>
</ul>
</li>
<li>加入房间后调用该方法切换用户角色：<ul>
<li>从观众角色切为主播：本端用户触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#ab5301ed7eb92a964c72040aff3ef3f18">onClientRoleChanged</a> 回调，远端用户触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a58de12309ab73e4b364fd5212af3c93c">onUserJoined</a> 回调。</li>
<li>从主播角色切为观众：本端用户触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#ab5301ed7eb92a964c72040aff3ef3f18">onClientRoleChanged</a> 回调，远端用户触发 onUserleft 回调。 </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30001（kNERtcErrFatal)：引擎未创建成功。</li>
<li>30005（kNERtcErrInvalidState)：当前状态不支持的操作，不支持切换角色（主播/观众）。</li>
<li>30101（kNERtcErrChannelNotJoined): 尚未加入房间。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa67423b097cdedc4b9899b4156de38cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67423b097cdedc4b9899b4156de38cb">&#9670;&nbsp;</a></span>setExcludeWindowList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setExcludeWindowList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a93322486d4e060256d5bff61c75fad53">source_id_t</a> *&#160;</td>
          <td class="paramname"><em>window_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置共享整个屏幕或屏幕指定区域时，需要屏蔽的窗口列表。 <br  />
开启屏幕共享时，可以通过 <a class="el" href="structnertc_1_1_n_e_rtc_screen_capture_parameters.html">NERtcScreenCaptureParameters</a> 设置需要屏蔽的窗口列表；开发者可以在开启屏幕共享后，通过此方法动态调整需要屏蔽的窗口列表。被屏蔽的窗口不会显示在屏幕共享区域中。 </p><dl class="section note"><dt>注解</dt><dd><ul>
<li>在 Windows 平台中，该接口在屏幕共享过程中可动态调用；在 macOS 平台中，该接口自 V4.6.0 开始支持在屏幕共享过程中动态调用。</li>
<li>在 Windows 平台中，某些窗口在被屏蔽之后，如果被置于图层最上层，此窗口图像可能会黑屏。此时会触发 onScreenCaptureStatus.kScreenCaptureStatusCovered 回调，建议应用层在触发此回调时提醒用户将待分享的窗口置于最上层。 </li>
</ul>
</dd></dl>
<dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">window_list</td><td>需要屏蔽的窗口 ID 列表。 </td></tr>
    <tr><td class="paramname">count</td><td>需屏蔽的窗口的数量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功</li>
<li>其他: 方法调用失败 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afec51e2fbb70c3421c07eca49217f57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec51e2fbb70c3421c07eca49217f57a">&#9670;&nbsp;</a></span>setExternalVideoSource() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setExternalVideoSource </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>开启或关闭外部视频源数据输入。 <br  />
通过该方法启用外部视频数据输入功能时，需要通过 <a class="el" href="classnertc_1_1_i_video_device_manager.html#a8da8a94bec7110acc5fc0416a4b812f6">IVideoDeviceManager::setDevice</a> 设置 kNERtcExternalVideoDeviceID 为外部视频输入源 ID。 </p><dl class="section note"><dt>注解</dt><dd>该方法设置内部引擎为启用状态，在 <a class="el" href="classnertc_1_1_i_rtc_engine.html#a6fbc54a71986a4a4a1c9c24d2c29e884">leaveChannel</a> 后仍然有效。 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enabled</td><td>是否启用外部视频源数据输入。<ul>
<li>true: 开启外部视频源数据输入；</li>
<li>false: 关闭外部视频源数据输入 (默认)。 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功；</li>
<li>其他: 方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afecc35c54940975f666235843e0a2da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afecc35c54940975f666235843e0a2da3">&#9670;&nbsp;</a></span>setExternalVideoSource() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setExternalVideoSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>开启或关闭外部视频源数据输入。 <br  />
通过该方法启用外部视频数据输入功能时，需要通过 <a class="el" href="classnertc_1_1_i_video_device_manager.html#a8da8a94bec7110acc5fc0416a4b812f6">IVideoDeviceManager::setDevice</a> 设置 kNERtcExternalVideoDeviceID 为外部视频输入源 ID。 </p><dl class="section note"><dt>注解</dt><dd>该方法设置内部引擎为启用状态，在 <a class="el" href="classnertc_1_1_i_rtc_engine.html#a6fbc54a71986a4a4a1c9c24d2c29e884">leaveChannel</a> 后仍然有效。 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>视频流通道类型 <a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a><ul>
<li>kNERTCVideoStreamMain，打开或关闭主流通道的外部源</li>
<li>kNERTCVideoStreamSub， 打开或关闭辅流通道的外部源 </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enabled</td><td>是否外部视频源数据输入:<ul>
<li>true: 开启外部视频源数据输入；</li>
<li>false: 关闭外部视频源数据输入 (默认)。 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功；</li>
<li>其他: 方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae5b72cc5bea080f38b1665d655161edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b72cc5bea080f38b1665d655161edf">&#9670;&nbsp;</a></span>setLocalMediaPriority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setLocalMediaPriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a593accc20cb8c058a67f86f7ad785790">NERtcMediaPriorityType</a>&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_preemptive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置本地用户的媒体流优先级。 <br  />
 通过此接口可以实现设置某用户的媒体流优先级为高，从而弱网环境下 SDK 会优先保证其他用户收到的该用户媒体流的质量。 </p><dl class="section since"><dt>自从</dt><dd>V4.2.0 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化之后调用此接口，且该方法仅可在加入房间前调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>一个音视频房间中只有一个高优先级的用户。建议房间中只有一位用户调用 setLocalMediaPriority 将本端媒体流设为高优先级，否则需要开启抢占模式，保证本地用户的高优先级设置生效。</li>
<li>调用 <a class="el" href="classnertc_1_1_i_rtc_engine.html#a827ecfee86c395f564a18012fa919b59">switchChannel</a> 方法快速切换房间后，媒体优先级会恢复为默认值，即普通优先级。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明 </dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>priority </td><td><a class="el" href="namespacenertc.html#a593accc20cb8c058a67f86f7ad785790">NERtcMediaPriorityType</a> </td><td>本地用户的媒体流优先级，默认为 kNERtcMediaPriorityNormal，即普通优先级。  </td></tr>
<tr>
<td>is_preemptive </td><td>bool </td><td>是否开启抢占模式，默认为 NO，即不开启：<ul>
<li>
true：开启抢占模式。抢占模式开启时，本地用户可以抢占其他用户的高优先级，被抢占的用户的媒体优先级变为普通优先级，在抢占者退出房间后，其他用户的优先级仍旧维持普通优先级。</li>
<li>
false：关闭抢占模式。抢占模式关闭时，如果房间中已有高优先级用户，则本地用户的高优先级设置不生效，仍旧为普通优先级。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><a class="code" href="namespacenertc.html#a593accc20cb8c058a67f86f7ad785790">nertc::NERtcMediaPriorityType</a> priority = nertc::kNERtcMediaPriorityNormal；</div>
<div class="line"><span class="keywordtype">bool</span> is_preemptive = <span class="keyword">false</span>;</div>
<div class="line">rtc_channel_-&gt;setLocalMediaPriority(priority, is_preemptive);</div>
<div class="ttc" id="anamespacenertc_html_a593accc20cb8c058a67f86f7ad785790"><div class="ttname"><a href="namespacenertc.html#a593accc20cb8c058a67f86f7ad785790">nertc::NERtcMediaPriorityType</a></div><div class="ttdeci">NERtcMediaPriorityType</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:306</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30005（kNERtcErrInvalidState）：状态错误，比如引擎尚未初始化或者已经加入房间。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5d2aeae78634a66cf2b5262ba933c1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2aeae78634a66cf2b5262ba933c1df">&#9670;&nbsp;</a></span>setLocalPublishFallbackOption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setLocalPublishFallbackOption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a1f81e05e0a5bbcd0807479d4b1c03d06">NERtcStreamFallbackOption</a>&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置弱网条件下发布的音视频流回退选项。 <br  />
在网络不理想的环境下，发布的音视频质量都会下降。使用该接口并将 option 设置为 <a class="el" href="namespacenertc.html#a1f81e05e0a5bbcd0807479d4b1c03d06a5f0d42ec453877c59369572e54ef479a">kNERtcStreamFallbackAudioOnly</a> 后：</p><ul>
<li>SDK 会在上行弱网且音视频质量严重受影响时，自动关断视频流，尽量保证音频质量。</li>
<li>同时 SDK 会持续监控网络质量，并在网络质量改善时恢复音视频流。</li>
<li>当本地发布的音视频流回退为音频流时，或由音频流恢复为音视频流时，SDK 会触发本地发布的媒体流已回退为音频流 onLocalPublishFallbackToAudioOnly 回调。 </li>
</ul>
<dl class="section note"><dt>注解</dt><dd>请在加入房间（joinChannel）前调用此方法。 </dd></dl>
<dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>发布音视频流的回退选项，默认为不开启回退 kNERtcStreamFallbackAudioOnly。详细信息请参考 nertc::NERTCStreamFallbackOption 。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><div class="fragment"><div class="line">0 </div>
</div><!-- fragment --> 方法调用成功，其他调用失败 </dd></dl>

</div>
</div>
<a id="aad76fc9270c220d4c582f416463490b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad76fc9270c220d4c582f416463490b7">&#9670;&nbsp;</a></span>setLocalRenderMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setLocalRenderMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a410a5b7182fad6ff52def434a58de4e5">NERtcVideoScalingMode</a>&#160;</td>
          <td class="paramname"><em>scaling_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置画布中本地视频画面的显示模式。 <br  />
 通过本接口可以实现设置本地视频画面的适应性，即是否裁剪或缩放。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机 </dt><dd>请在初始化后调用该方法，且该方法仅可在加入房间后调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>纯音频 SDK 禁用该接口，如需使用请前往<a href="https://doc.yunxin.163.com/nertc/sdk-download" target="_blank">云信官网</a>下载并替换成视频 SDK。 </dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>scaling_mode </td><td>int </td><td>视频显示模式类型：<ul>
<li>
kNERtcVideoScaleFit（0）:适应视频，视频尺寸等比缩放。优先保证视频内容全部显示。若视频尺寸与显示视窗尺寸不一致，视窗未被填满的区域填充背景色。</li>
<li>
kNERtcVideoScaleFullFill（1）：视频尺寸非等比缩放。保证视频内容全部显示，且填满视窗。</li>
<li>
kNERtcVideoScaleCropFill（2）：适应区域，视频尺寸等比缩放。保证所有区域被填满，视频超出部分会被裁剪。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line">rtc_channel_-&gt;setLocalRenderMode(<a class="code" href="namespacenertc.html#a410a5b7182fad6ff52def434a58de4e5a7189e90604dcb50626d15981b89c2409">nertc::kNERtcVideoScaleFit</a>);</div>
<div class="ttc" id="anamespacenertc_html_a410a5b7182fad6ff52def434a58de4e5a7189e90604dcb50626d15981b89c2409"><div class="ttname"><a href="namespacenertc.html#a410a5b7182fad6ff52def434a58de4e5a7189e90604dcb50626d15981b89c2409">nertc::kNERtcVideoScaleFit</a></div><div class="ttdeci">@ kNERtcVideoScaleFit</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:2085</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30005（kNERtcErrInvalidState）：当前状态不支持的操作，比如引擎尚未初始化。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="accee985db847591fcf8122ca0df1aacb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accee985db847591fcf8122ca0df1aacb">&#9670;&nbsp;</a></span>setLocalSubStreamRenderMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setLocalSubStreamRenderMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a410a5b7182fad6ff52def434a58de4e5">NERtcVideoScalingMode</a>&#160;</td>
          <td class="paramname"><em>scaling_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置本端的屏幕共享辅流视频显示模式。 <br  />
该方法设置本地视图显示模式。 App 可以多次调用此方法更改显示模式。 </p><dl class="section note"><dt>注解</dt><dd>调用此方法前，必须先通过 setupLocalSubStreamVideoCanvas 设置本地辅流画布。 </dd></dl>
<dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scaling_mode</td><td>视频显示模式。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功。</li>
<li>其他: 方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa4b33bef358285686ebd67dc8b1a68b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b33bef358285686ebd67dc8b1a68b1">&#9670;&nbsp;</a></span>setLocalVideoMirrorMode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setLocalVideoMirrorMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#aa3abbd3e5bbe492f54f9720d0b25d3f8">NERtcVideoMirrorMode</a>&#160;</td>
          <td class="paramname"><em>mirror_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置本地视频镜像模式。 <br  />
该方法用于设置本地视频是否开启镜像模式，即画面是否左右翻转。 </p><dl class="section note"><dt>注解</dt><dd><ul>
<li>该方法仅适用于视频主流，若您希望设置视频辅流的镜像模式，请调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#aa4b33bef358285686ebd67dc8b1a68b1">IRtcChannel::setLocalVideoMirrorMode</a>(NERtcVideoStreamType type, NERtcVideoMirrorMode mirror_mode "setLocalVideoMirrorMode" 方法。</li>
<li>该方法用于 <a class="el" href="classnertc_1_1_i_rtc_channel.html#a3f35f36c7bf378d5e4c14eec337a2500">setupLocalVideoCanvas</a> 之后。</li>
<li>本地的视频镜像模式仅影响本地用户所见，不影响远端用户所见。App 可以多次调用此方法更改镜像模式。 </li>
</ul>
</dd></dl>
<dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mirror_mode</td><td>视频镜像模式。详细信息请参考 <a class="el" href="namespacenertc.html#aa3abbd3e5bbe492f54f9720d0b25d3f8">NERtcVideoMirrorMode</a>。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功；</li>
<li>其他: 方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aeb23c7a8ef637316507e3eb6793ae1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb23c7a8ef637316507e3eb6793ae1e9">&#9670;&nbsp;</a></span>setLocalVideoMirrorMode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setLocalVideoMirrorMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#aa3abbd3e5bbe492f54f9720d0b25d3f8">NERtcVideoMirrorMode</a>&#160;</td>
          <td class="paramname"><em>mirror_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置本地视频镜像模式。 <br  />
通过此接口可以设置本地视频是否开启镜像模式，即画面是否左右翻转。 </p><dl class="section since"><dt>自从</dt><dd>V4.6.20 </dd></dl>
<dl class="section user"><dt>使用前提</dt><dd>请在通过 <a class="el" href="classnertc_1_1_i_rtc_channel.html#a3f35f36c7bf378d5e4c14eec337a2500">setupLocalVideoCanvas</a> 接口设置本地视频画布后调用该方法。 </dd></dl>
<dl class="section user"><dt>调用时机 </dt><dd>请在初始化后调用该方法，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>纯音频 SDK 禁用该接口，如需使用请前往<a href="https://doc.yunxin.163.com/nertc/sdk-download" target="_blank">云信官网</a>下载并替换成视频 SDK。</li>
<li>本地视频画布的镜像模式仅影响本地用户所见，不影响远端用户所见。您的应用层可以多次调用此方法更改镜像模式。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>type </td><td><a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a> </td><td>视频通道类型：<ul>
<li>
kNERtcVideoStreamMain：主流。</li>
<li>
kNERtcVideoStreamSub：辅流。  </li>
</ul>
</td></tr>
<tr>
<td>mirror_mode </td><td><a class="el" href="namespacenertc.html#aa3abbd3e5bbe492f54f9720d0b25d3f8">NERtcVideoMirrorMode</a> </td><td>视频镜像模式：<ul>
<li>
kNERtcVideoMirrorModeAuto：由 SDK 决定是否启用镜像模式。</li>
<li>
kNERtcVideoMirrorModeEnabled：启用镜像模式。</li>
<li>
kNERtcVideoMirrorModeDisabled（默认）：关闭镜像模式。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//设置本地视频主流的镜像模式</span></div>
<div class="line"><a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">nertc::NERtcVideoStreamType</a> type = <a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a15fcc7ab62484b7ed86661f6e7188a09">nertc::NERtcVideoStreamType::kNERTCVideoStreamMain</a>;</div>
<div class="line"><a class="code" href="namespacenertc.html#aa3abbd3e5bbe492f54f9720d0b25d3f8">nertc::NERtcVideoMirrorMode</a> mirror_mode = <a class="code" href="namespacenertc.html#aa3abbd3e5bbe492f54f9720d0b25d3f8aea97015991c737c9c4ff72e987dd1f13">kNERtcVideoMirrorModeEnabled</a>;</div>
<div class="line">rtc_channel_-&gt;setLocalVideoMirrorMode(type, mirror_mode);</div>
<div class="line"><span class="comment">//设置本地视频辅流的镜像模式</span></div>
<div class="line"><a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">nertc::NERtcVideoStreamType</a> type = <a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a101f9d507d87b67bc5f6da90f336f3fb">nertc::NERtcVideoStreamType::kNERTCVideoStreamSub</a>;</div>
<div class="line"><a class="code" href="namespacenertc.html#aa3abbd3e5bbe492f54f9720d0b25d3f8">nertc::NERtcVideoMirrorMode</a> mirror_mode = <a class="code" href="namespacenertc.html#aa3abbd3e5bbe492f54f9720d0b25d3f8aea97015991c737c9c4ff72e987dd1f13">kNERtcVideoMirrorModeEnabled</a>;</div>
<div class="line">rtc_channel_-&gt;setLocalVideoMirrorMode(type, mirror_mode);</div>
<div class="ttc" id="anamespacenertc_html_aa3abbd3e5bbe492f54f9720d0b25d3f8"><div class="ttname"><a href="namespacenertc.html#aa3abbd3e5bbe492f54f9720d0b25d3f8">nertc::NERtcVideoMirrorMode</a></div><div class="ttdeci">NERtcVideoMirrorMode</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:2116</div></div>
<div class="ttc" id="anamespacenertc_html_aa3abbd3e5bbe492f54f9720d0b25d3f8aea97015991c737c9c4ff72e987dd1f13"><div class="ttname"><a href="namespacenertc.html#aa3abbd3e5bbe492f54f9720d0b25d3f8aea97015991c737c9c4ff72e987dd1f13">nertc::kNERtcVideoMirrorModeEnabled</a></div><div class="ttdeci">@ kNERtcVideoMirrorModeEnabled</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:2131</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关接口</dt><dd><ul>
<li><a class="el" href="classnertc_1_1_i_rtc_channel.html#a3f35f36c7bf378d5e4c14eec337a2500">setupLocalVideoCanvas</a>：通过此接口也设置本地视频画布的镜像模式，不影响远端用户所见。</li>
<li><a class="el" href="classnertc_1_1_i_rtc_channel.html#a1288ec625e5b17892666cd5f70954a99">setupRemoteVideoCanvas</a>：通过此接口设置远端用户视频画布的镜像模式，不影响远端用户所见。</li>
<li><a class="el" href="classnertc_1_1_i_rtc_channel.html#a92a6af7d6825b548b6a5775ceb76bc6d">setVideoConfig</a>：通过此接口设置本地视频的镜像模式，影响远端用户看到的视频画面。 </li>
</ul>
</dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad245bb0f193db33ff2508336f09e7611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad245bb0f193db33ff2508336f09e7611">&#9670;&nbsp;</a></span>setRangeAudioMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setRangeAudioMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a64b693fd44286322cd9d4957b0e0a763">NERtcRangeAudioMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置范围语音模式 </p><dl class="section note"><dt>注解</dt><dd>此接口在加入房间前后均可调用。 </dd>
<dd>
若要使用范围语音功能需要入会前调用一次。 </dd></dl>
<dl class="section since"><dt>自从</dt><dd>V5.5.10 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>范围语音模式 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功</li>
<li>其他: 调用失败 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a88ea9533db5469ad79b2a07944967f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ea9533db5469ad79b2a07944967f81">&#9670;&nbsp;</a></span>setRangeAudioTeamID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setRangeAudioTeamID </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>team_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置范围语音小队 </p><dl class="section since"><dt>自从</dt><dd>V5.5.10 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>此接口在加入房间前后均可调用。 </dd>
<dd>
若要使用范围语音功能需要入会前调用一次。 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">team_id</td><td>小队ID, 有效值: &gt;=0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功</li>
<li>其他: 调用失败 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a87d04c6b4e6559bcf9c2f79a15b7e26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d04c6b4e6559bcf9c2f79a15b7e26e">&#9670;&nbsp;</a></span>setRemoteHighPriorityAudioStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setRemoteHighPriorityAudioStream </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a>&#160;</td>
          <td class="paramname"><em>uid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置远端用户音频流为高优先级。 支持在音频自动订阅的情况下，设置某一个远端用户的音频为最高优先级，可以优先听到该用户的音频。 </p><dl class="section note"><dt>注解</dt><dd><ul>
<li>该接口需要通话中设置，并需要自动订阅打开（默认打开）。</li>
<li>该接口只能设置一个用户的优先级，后设置的会覆盖之前的设置。</li>
<li>该接口通话结束后，优先级设置重置。 </li>
</ul>
</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enabled</td><td>是否设置音频订阅优先级。<ul>
<li>true：设置音频订阅优先级。</li>
<li>false：取消设置音频订阅优先级。 </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uid</td><td>用户 ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功。</li>
<li>其他: 方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0fe8c3428784d9290e9842e89473040d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe8c3428784d9290e9842e89473040d">&#9670;&nbsp;</a></span>setRemoteRenderMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setRemoteRenderMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a>&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a410a5b7182fad6ff52def434a58de4e5">NERtcVideoScalingMode</a>&#160;</td>
          <td class="paramname"><em>scaling_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置远端视图显示模式。 该方法设置远端视图显示模式。App 可以多次调用此方法更改显示模式。 </p><dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uid</td><td>远端用户 ID。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scaling_mode</td><td>视频显示模式: <a class="el" href="namespacenertc.html#a410a5b7182fad6ff52def434a58de4e5">NERtcVideoScalingMode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功；</li>
<li>其他: 方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6486d19b8dd550149b31e7a19ab7d4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6486d19b8dd550149b31e7a19ab7d4d3">&#9670;&nbsp;</a></span>setRemoteSubscribeFallbackOption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setRemoteSubscribeFallbackOption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a1f81e05e0a5bbcd0807479d4b1c03d06">NERtcStreamFallbackOption</a>&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置弱网条件下订阅的音视频流回退选项。 <br  />
弱网环境下，订阅的音视频质量会下降。使用该接口并将 option 设置为 <a class="el" href="namespacenertc.html#a1f81e05e0a5bbcd0807479d4b1c03d06abd43ad67272ec2be41af037fcaa79c8c">kNERtcStreamFallbackVideoStreamLow</a> 或者 <a class="el" href="namespacenertc.html#a1f81e05e0a5bbcd0807479d4b1c03d06a5f0d42ec453877c59369572e54ef479a">kNERtcStreamFallbackAudioOnly</a> 后：</p><ul>
<li>SDK 会在下行弱网且音视频质量严重受影响时，将视频流切换为小流，或关断视频流，从而保证或提高通信质量。</li>
<li>SDK 会持续监控网络质量，并在网络质量改善时自动恢复音视频流。</li>
<li>当远端订阅流回退为音频流时，或由音频流恢复为音视频流时，SDK 会触发远端订阅流已回退为音频流 onRemoteSubscribeFallbackToAudioOnly 回调。 </li>
</ul>
<dl class="section note"><dt>注解</dt><dd>请在加入房间（joinChannel）前调用此方法。 </dd></dl>
<dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>订阅音视频流的回退选项，默认为弱网时回退到视频小流 kNERtcStreamFallbackVideoStreamLow。详细信息请参考 nertc::NERTCStreamFallbackOption 。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><div class="fragment"><div class="line">0 </div>
</div><!-- fragment --> 方法调用成功，其他调用失败 </dd></dl>

</div>
</div>
<a id="a4bd6e65efbf7a5dc6063dd32eb08b245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd6e65efbf7a5dc6063dd32eb08b245">&#9670;&nbsp;</a></span>setRemoteSubSteamRenderMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setRemoteSubSteamRenderMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a>&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a410a5b7182fad6ff52def434a58de4e5">NERtcVideoScalingMode</a>&#160;</td>
          <td class="paramname"><em>scaling_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置远端的屏幕共享辅流视频显示模式。 <br  />
在远端开启辅流形式的屏幕共享时使用。App 可以多次调用此方法更改显示模式。 </p><dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uid</td><td>远端用户 ID。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scaling_mode</td><td>视频显示模式。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功；</li>
<li>其他: 方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4da427bab24d4fdae61c088330383f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da427bab24d4fdae61c088330383f5e">&#9670;&nbsp;</a></span>setScreenCaptureMouseCursor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setScreenCaptureMouseCursor </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>capture_cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在共享屏幕或窗口时，更新是否显示鼠标。 </p><dl class="section since"><dt>自从</dt><dd>V4.6.10 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">capture_cursor</td><td>屏幕共享时是否捕捉鼠标光标。<ul>
<li>true：共享屏幕时显示鼠标。</li>
<li>false：共享屏幕时不显示鼠标。 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功。</li>
<li>其他: 方法调用失败 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3ba6dcb73a38571d740dd0a1ef3f2cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba6dcb73a38571d740dd0a1ef3f2cef">&#9670;&nbsp;</a></span>setSpatializerRenderMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setSpatializerRenderMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a79ef6ed6b3b86c72c3b42f9736fe32c9">NERtcSpatializerRenderMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置空间音效的渲染模式 </p><dl class="section since"><dt>自从</dt><dd>V5.4.0 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>该接口不支持 Linux 平台 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化后调用此接口，且该方法在加入房间前才可调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>请先调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#a5e22a70ba1c0ab41b03c49ea86ba8ad6">enableSpatializer</a> 接口启用空间音效，再调用本接口。 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>渲染模式，具体请参见 <a class="el" href="namespacenertc.html#a79ef6ed6b3b86c72c3b42f9736fe32c9">NERtcSpatializerRenderMode</a>，默认值 <a class="el" href="namespacenertc.html#a79ef6ed6b3b86c72c3b42f9736fe32c9ad53569cd1636337107cf78078f6db526">kNERtcSpatializerRenderBinauralHighQuality</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功</li>
<li>其他: 调用失败 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a02c23b9778c38db526288df4bb0981f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c23b9778c38db526288df4bb0981f3">&#9670;&nbsp;</a></span>setSpatializerRoomProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setSpatializerRoomProperty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnertc_1_1_n_e_rtc_spatializer_room_property.html">NERtcSpatializerRoomProperty</a> &amp;&#160;</td>
          <td class="paramname"><em>room_property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置空间音效的房间混响属性 </p><dl class="section since"><dt>自从</dt><dd>V5.4.0 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>该接口不支持 Linux 平台 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化后调用此接口，且该方法在加入房间前才可调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>请先调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#a5e22a70ba1c0ab41b03c49ea86ba8ad6">enableSpatializer</a> 接口启用空间音效，再调用本接口。 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">room_property</td><td>房间属性，具体请参见 <a class="el" href="structnertc_1_1_n_e_rtc_spatializer_room_property.html">NERtcSpatializerRoomProperty</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功</li>
<li>其他: 调用失败 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5929999546232013f09cead668a85223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5929999546232013f09cead668a85223">&#9670;&nbsp;</a></span>setStatsObserver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setStatsObserver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnertc_1_1_i_rtc_media_stats_observer.html">IRtcMediaStatsObserver</a> *&#160;</td>
          <td class="paramname"><em>observer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>注册统计信息观测器。 </p><dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">observer</td><td>统计信息观测器 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功；</li>
<li>其他: 方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a256c38c14427923a69b2de067cd037dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256c38c14427923a69b2de067cd037dc">&#9670;&nbsp;</a></span>setSubscribeAudioAllowlist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setSubscribeAudioAllowlist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> *&#160;</td>
          <td class="paramname"><em>uid_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>你可以调用该方法指定只订阅的音频流。 </p><dl class="section note"><dt>注解</dt><dd><ul>
<li>此接口需要在加入房间成功后调用。</li>
<li>对于调用接口时不在房间的 uid 不生效。 </li>
</ul>
</dd></dl>
<dl class="section since"><dt>自从</dt><dd>V5.4.101 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uid_array</td><td>只订阅此 用户uid列表 的音频。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>此列表为全量列表。如果列表为空或 null，取消订阅白名单。 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>uid_array 的数组长度。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0：方法调用成功。</li>
<li>其他：方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5a348216eeeeebb3549078f73faa8d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a348216eeeeebb3549078f73faa8d85">&#9670;&nbsp;</a></span>setSubscribeAudioBlocklist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setSubscribeAudioBlocklist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a80f28ee70a6ad8a9cb24981313b0059b">NERtcAudioStreamType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> *&#160;</td>
          <td class="paramname"><em>uid_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>你可以调用该方法指定不订阅的音频流。 </p><dl class="section note"><dt>注解</dt><dd><ul>
<li>此接口需要在加入房间成功后调用。</li>
<li>对于调用接口时不在房间的 uid 不生效。 </li>
</ul>
</dd></dl>
<dl class="section since"><dt>自从</dt><dd>V5.4.101 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uid_array</td><td>不订阅此 用户uid列表 的音频。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>此列表为全量列表。如果列表为空或 null，取消订阅黑名单。 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>uid_array 的数组长度。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0：方法调用成功。</li>
<li>其他：方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aebc83b37cf5398d051088eb763622f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc83b37cf5398d051088eb763622f18">&#9670;&nbsp;</a></span>setupLocalSubStreamVideoCanvas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setupLocalSubStreamVideoCanvas </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnertc_1_1_n_e_rtc_video_canvas.html">NERtcVideoCanvas</a> *&#160;</td>
          <td class="paramname"><em>canvas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置本地辅流视频画布。</p><ul>
<li>该方法设置本地辅流视频显示信息。App 通过调用此接口绑定本地辅流的显示视窗（view）。</li>
<li>在 App 开发中，通常在初始化后调用该方法进行本地视频设置，然后再加入房间。 <dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">canvas</td><td>视频画布信息。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd></dd></dl>
</li>
<li>0: 方法调用成功。</li>
<li>其他: 方法调用失败。 </li>
</ul>

</div>
</div>
<a id="a3f35f36c7bf378d5e4c14eec337a2500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f35f36c7bf378d5e4c14eec337a2500">&#9670;&nbsp;</a></span>setupLocalVideoCanvas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setupLocalVideoCanvas </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnertc_1_1_n_e_rtc_video_canvas.html">NERtcVideoCanvas</a> *&#160;</td>
          <td class="paramname"><em>canvas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置本地用户视图。 <br  />
 通过本接口可以实现绑定本地用户和显示视图，并设置本地用户视图在本地显示时的镜像模式和裁减比例，只影响本地用户看到的视频画面。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机 </dt><dd>请在初始化后调用该方法，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>纯音频 SDK 禁用该接口，如需使用请前往<a href="https://doc.yunxin.163.com/nertc/sdk-download" target="_blank">云信官网</a>下载并替换成视频 SDK。</li>
<li>在实际业务中，通常建议在初始化后即调用该方法进行本地视图设置，然后再加入房间或开启预览；若您开发的是 macOS 平台的 App，若使用的是外部渲染，必须在初始化 SDK 时设置本地视图。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>canvas </td><td><a class="el" href="structnertc_1_1_n_e_rtc_video_canvas.html">NERtcVideoCanvas</a>  </td><td>本地用户视频的画布。设置为 NULL 表示取消并释放已设置的画布，详细信息请参考 <a class="el" href="structnertc_1_1_n_e_rtc_video_canvas.html">NERtcVideoCanvas</a>。  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html">nertc::NERtcVideoCanvas</a> canvas;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#a33c22abb5bb5dd9f94fb587367284026">cb</a> = <span class="keyword">nullptr</span>;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#a0a5afd8e0817806f1afc1da29b39e461">user_data</a> = <span class="keyword">nullptr</span>;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#ab75d8766a11caf1be65102a7639a5c2c">window</a> = window;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#ad9063ff3bf1a7443c7f90761f3b43e19">scaling_mode</a> = <a class="code" href="namespacenertc.html#a410a5b7182fad6ff52def434a58de4e5a7189e90604dcb50626d15981b89c2409">nertc::kNERtcVideoScaleFit</a>;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#ab2c3f29cccd971d63c055a8df3320053">mirror_mode</a> = <a class="code" href="namespacenertc.html#aa3abbd3e5bbe492f54f9720d0b25d3f8a35100cf833e23603ab1a6170bf1c1683">nertc::kNERtcVideoMirrorModeAuto</a>;</div>
<div class="line">rtc_channel_-&gt;setupLocalVideoCanvas(canvas)</div>
<div class="ttc" id="anamespacenertc_html_aa3abbd3e5bbe492f54f9720d0b25d3f8a35100cf833e23603ab1a6170bf1c1683"><div class="ttname"><a href="namespacenertc.html#aa3abbd3e5bbe492f54f9720d0b25d3f8a35100cf833e23603ab1a6170bf1c1683">nertc::kNERtcVideoMirrorModeAuto</a></div><div class="ttdeci">@ kNERtcVideoMirrorModeAuto</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:2122</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_canvas_html"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_canvas.html">nertc::NERtcVideoCanvas</a></div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:4235</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_canvas_html_a0a5afd8e0817806f1afc1da29b39e461"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_canvas.html#a0a5afd8e0817806f1afc1da29b39e461">nertc::NERtcVideoCanvas::user_data</a></div><div class="ttdeci">void * user_data</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:4257</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_canvas_html_a33c22abb5bb5dd9f94fb587367284026"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_canvas.html#a33c22abb5bb5dd9f94fb587367284026">nertc::NERtcVideoCanvas::cb</a></div><div class="ttdeci">onFrameDataCallback cb</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:4246</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_canvas_html_ab2c3f29cccd971d63c055a8df3320053"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_canvas.html#ab2c3f29cccd971d63c055a8df3320053">nertc::NERtcVideoCanvas::mirror_mode</a></div><div class="ttdeci">NERtcVideoMirrorMode mirror_mode</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:4292</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_canvas_html_ab75d8766a11caf1be65102a7639a5c2c"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_canvas.html#ab75d8766a11caf1be65102a7639a5c2c">nertc::NERtcVideoCanvas::window</a></div><div class="ttdeci">void * window</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:4269</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_canvas_html_ad9063ff3bf1a7443c7f90761f3b43e19"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_canvas.html#ad9063ff3bf1a7443c7f90761f3b43e19">nertc::NERtcVideoCanvas::scaling_mode</a></div><div class="ttdeci">NERtcVideoScalingMode scaling_mode</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:4278</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关接口</dt><dd>若您希望在通话中更新本地用户视图的渲染或镜像模式，请使用 <a class="el" href="classnertc_1_1_i_rtc_engine_ex.html#aa0e5456afae0c8b1f553de8884dabb5d">setLocalRenderMode</a> 方法。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30001（kNERtcErrFatal）：画布创建失败。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6d6767fcbb866ec12dc1ee274f87c1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6767fcbb866ec12dc1ee274f87c1c3">&#9670;&nbsp;</a></span>setupRemoteSubStreamVideoCanvas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setupRemoteSubStreamVideoCanvas </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a>&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnertc_1_1_n_e_rtc_video_canvas.html">NERtcVideoCanvas</a> *&#160;</td>
          <td class="paramname"><em>canvas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置远端用户的视频辅流画布。 <br  />
通过此接口可以实现绑定远端用户和对应辅流的显示视图，即指定某个 uid 使用对应的画布显示。 </p><dl class="section since"><dt>自从</dt><dd>V3.9.0 </dd></dl>
<dl class="section user"><dt>使用前提</dt><dd>建议在收到远端用户加入房间的 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a58de12309ab73e4b364fd5212af3c93c">onUserJoined</a> 回调后，再调用此接口通过回调返回的 uid 设置对应视图。 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化之后调用此接口，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>纯音频 SDK 禁用该接口，如需使用请前往云信官网下载并替换成视频 SDK。</li>
<li>退出房间后，SDK 会清除远端用户和画布的的绑定关系，该设置自动失效。</li>
<li>若您使用的是 macOS 平台，请注意不要动态切换画布，若您移除画布，SDK 会自动停止订阅对应用户的视频流；若您修改画布，可能无法正常生效。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>canvas </td><td>NERtcVideoCanvas* </td><td>视频画布。详细信息请参考 <a class="el" href="structnertc_1_1_n_e_rtc_video_canvas.html">NERtcVideoCanvas</a>。  </td></tr>
<tr>
<td>uid </td><td>uid_t </td><td>远端用户 ID。  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html">nertc::NERtcVideoCanvas</a> canvas;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#a33c22abb5bb5dd9f94fb587367284026">cb</a> = onRemoteFrameDataCallback;<span class="comment">//回调和窗口 2选1，全部不填代表移除</span></div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#a0a5afd8e0817806f1afc1da29b39e461">user_data</a> = <span class="keyword">nullptr</span>;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#ab75d8766a11caf1be65102a7639a5c2c">window</a> = window;</div>
<div class="line"><span class="keywordflow">if</span> (rtc_channel_) {</div>
<div class="line">ret = rtc_channel_-&gt;setupRemoteSubStreamVideoCanvas(uid, &amp;canvas);</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关接口</dt><dd>可以调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#a0fe8c3428784d9290e9842e89473040d">setRemoteRenderMode</a> 方法在通话过程中更新远端用户视图的渲染模式。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30004（kNERtcErrNotSupported）：不支持的操作，比如纯音频 SDK 不支持该功能。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1288ec625e5b17892666cd5f70954a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1288ec625e5b17892666cd5f70954a99">&#9670;&nbsp;</a></span>setupRemoteVideoCanvas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setupRemoteVideoCanvas </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a>&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnertc_1_1_n_e_rtc_video_canvas.html">NERtcVideoCanvas</a> *&#160;</td>
          <td class="paramname"><em>canvas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置远端用户视图。 <br  />
通过本接口可以实现绑定远端用户和显示视图，并设置远端用户视图在本地显示时的镜像模式和裁减比例，只影响本地用户看到的视频画面。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机 </dt><dd>请在初始化后调用该方法，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>您可以通过设置 canvas 参数为空以解除远端用户视图绑定；退出房间后，SDK 也会主动清除远端用户和视图的绑定关系。 </dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>canvas </td><td><a class="el" href="structnertc_1_1_n_e_rtc_video_canvas.html">NERtcVideoCanvas</a>  </td><td>远端用户视频的画布。  </td></tr>
<tr>
<td>uid </td><td>uid_t </td><td>远端用户的 ID。可以在 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a84a5b3eb47d7f0465082db4bd4bd4989">onUserJoined</a> 回调中获取。  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html">nertc::NERtcVideoCanvas</a> canvas;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#a33c22abb5bb5dd9f94fb587367284026">cb</a> = <span class="keyword">nullptr</span>;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#a0a5afd8e0817806f1afc1da29b39e461">user_data</a> = <span class="keyword">nullptr</span>;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#ab75d8766a11caf1be65102a7639a5c2c">window</a> = window;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#ad9063ff3bf1a7443c7f90761f3b43e19">scaling_mode</a> = <a class="code" href="namespacenertc.html#a410a5b7182fad6ff52def434a58de4e5a7189e90604dcb50626d15981b89c2409">nertc::kNERtcVideoScaleFit</a>; </div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#ab2c3f29cccd971d63c055a8df3320053">mirror_mode</a>  = <a class="code" href="namespacenertc.html#aa3abbd3e5bbe492f54f9720d0b25d3f8a35100cf833e23603ab1a6170bf1c1683">nertc::kNERtcVideoMirrorModeAuto</a>;</div>
<div class="line">rtc_channel_-&gt;setupRemoteVideoCanvas(uid, canvas);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关接口</dt><dd>若您希望在通话中更新远端用户视图的渲染模式，请调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#a0fe8c3428784d9290e9842e89473040d">setRemoteRenderMode</a> 方法。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30001（kNERtcErrFatal）：画布创建失败。</li>
<li>30005（kNERtcErrInvalidState）：当前状态不支持的操作，比如引擎尚未初始化。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae6236eb1eba4e3d34d9522cbbd84d782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6236eb1eba4e3d34d9522cbbd84d782">&#9670;&nbsp;</a></span>setVideoConfig() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setVideoConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnertc_1_1_n_e_rtc_video_config.html">NERtcVideoConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置视频编码属性。 <br  />
通过此接口可以设置视频主流的编码分辨率、裁剪模式、码率、帧率、带宽受限时的视频编码降级偏好、编码的镜像模式、编码的方向模式参数，详细信息请参考<a href="https://doc.yunxin.163.com/docs/jcyOTA0ODM/zYwMTQyNzE">设置视频属性</a>。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机 </dt><dd>请在初始化后调用该方法，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>纯音频 SDK 禁用该接口，如需使用请前往<a href="https://doc.yunxin.163.com/nertc/sdk-download" target="_blank">云信官网</a>下载并替换成视频 SDK。</li>
<li>每个属性对应一套视频参数，例如分辨率、帧率、码率等。所有设置的参数均为理想情况下的最大值。当视频引擎因网络环境等原因无法达到设置的分辨率、帧率或码率的最大值时，会取最接近最大值的那个值。</li>
<li>此接口为全量参数配置接口，重复调用此接口时，SDK 会刷新此前的所有参数配置，以最新的传参为准。所以每次修改配置时都需要设置所有参数，未设置的参数将取默认值。</li>
<li>自 V4.5.0 版本起，此方法设置实时生效；此前的版本中，此方法设置成功后，下次开启本端视频时生效。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>config </td><td><a class="el" href="structnertc_1_1_n_e_rtc_video_config.html">NERtcVideoConfig</a> </td><td>视频编码属性配置。  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><a class="code" href="structnertc_1_1_n_e_rtc_video_config.html">nertc::NERtcVideoConfig</a> video_config_ = {};</div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#a1bb6269b9476b32a156ab3b44e89cd5c">width</a> = 1920; <span class="comment">// 编码分辨率的宽</span></div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#a684048992662ab49a2f3f7ccb68da278">height</a> = 1080; <span class="comment">// 编码分辨率的高</span></div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#a75ec24e0422b7d565c80fb0ef00b0c2f">mirror_mode</a> = <a class="code" href="namespacenertc.html#aa3abbd3e5bbe492f54f9720d0b25d3f8a35100cf833e23603ab1a6170bf1c1683">nertc::kNERtcVideoMirrorModeAuto</a>; <span class="comment">// 视频镜像模式</span></div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#a6af3711df481be5794c8f2d32560cd6f">orientation_mode</a> = <a class="code" href="namespacenertc.html#aaa3dc5429ed6cb20020bced1c471ee7ea5e54f9567613901010475d0b0fd35e6d">nertc::kNERtcVideoOutputOrientationModeAdaptative</a>; <span class="comment">// 视频旋转的方向模式。</span></div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#a04fcd6d449dcacbd7818fdce480c1bd5">max_profile</a> = <a class="code" href="namespacenertc.html#a80b32c4c5cf6f4a36dbe6650ae859058a697f9e8e70fedcdc77404aae13afe4b9">nertc::kNERtcVideoProfileHD1080P</a>; <span class="comment">// 视频编码配置</span></div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#af8f97b4615b81e0efb7199ab3e349be1">crop_mode_</a> = <a class="code" href="namespacenertc.html#a350c51e2dbbe98fa1891f1ae1760d560a7fa7a12fd9e1189ec059bd26bbb4cd0c">nertc::kNERtcVideoCropModeDefault</a>;<span class="comment">//裁剪模式</span></div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#a897f6a121362a683b40b511b779e7b1c">bitrate</a> = 0; <span class="comment">// 视频编码的码率</span></div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#ac0a1d82431926b6a8f1d9db0ad703d27">min_bitrate</a> = 0;<span class="comment">//视频编码的最小码率</span></div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#af6b2c394608f911c4aab07df887624b7">framerate</a> = 30; <span class="comment">// 视频编码的帧率</span></div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#a812419614a119dad16f9d602b5ed6527">min_framerate</a> = 2;<span class="comment">// 视频编码的最小帧率</span></div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#a68247fbaffa5ce83a7f7185e743a9cc6">degradation_preference</a> = <a class="code" href="namespacenertc.html#a41cbc2850e52d1bcd3ba36dc3aff7eb1a126647a2e99c1caa5cfa8e5a45741c67">nertc::kNERtcDegradationDefault</a>;<span class="comment">// 带宽受限时的视频编码降级偏好</span></div>
<div class="line">rtc_channel_-&gt;setVideoConfig(video_config_);</div>
<div class="ttc" id="anamespacenertc_html_a350c51e2dbbe98fa1891f1ae1760d560a7fa7a12fd9e1189ec059bd26bbb4cd0c"><div class="ttname"><a href="namespacenertc.html#a350c51e2dbbe98fa1891f1ae1760d560a7fa7a12fd9e1189ec059bd26bbb4cd0c">nertc::kNERtcVideoCropModeDefault</a></div><div class="ttdeci">@ kNERtcVideoCropModeDefault</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:3420</div></div>
<div class="ttc" id="anamespacenertc_html_a41cbc2850e52d1bcd3ba36dc3aff7eb1a126647a2e99c1caa5cfa8e5a45741c67"><div class="ttname"><a href="namespacenertc.html#a41cbc2850e52d1bcd3ba36dc3aff7eb1a126647a2e99c1caa5cfa8e5a45741c67">nertc::kNERtcDegradationDefault</a></div><div class="ttdeci">@ kNERtcDegradationDefault</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:3547</div></div>
<div class="ttc" id="anamespacenertc_html_a80b32c4c5cf6f4a36dbe6650ae859058a697f9e8e70fedcdc77404aae13afe4b9"><div class="ttname"><a href="namespacenertc.html#a80b32c4c5cf6f4a36dbe6650ae859058a697f9e8e70fedcdc77404aae13afe4b9">nertc::kNERtcVideoProfileHD1080P</a></div><div class="ttdeci">@ kNERtcVideoProfileHD1080P</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:1676</div></div>
<div class="ttc" id="anamespacenertc_html_aaa3dc5429ed6cb20020bced1c471ee7ea5e54f9567613901010475d0b0fd35e6d"><div class="ttname"><a href="namespacenertc.html#aaa3dc5429ed6cb20020bced1c471ee7ea5e54f9567613901010475d0b0fd35e6d">nertc::kNERtcVideoOutputOrientationModeAdaptative</a></div><div class="ttdeci">@ kNERtcVideoOutputOrientationModeAdaptative</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:2168</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_config_html_a04fcd6d449dcacbd7818fdce480c1bd5"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_config.html#a04fcd6d449dcacbd7818fdce480c1bd5">nertc::NERtcVideoConfig::max_profile</a></div><div class="ttdeci">NERtcVideoProfileType max_profile</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:3599</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_config_html_a1bb6269b9476b32a156ab3b44e89cd5c"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_config.html#a1bb6269b9476b32a156ab3b44e89cd5c">nertc::NERtcVideoConfig::width</a></div><div class="ttdeci">uint32_t width</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:3618</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_config_html_a68247fbaffa5ce83a7f7185e743a9cc6"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_config.html#a68247fbaffa5ce83a7f7185e743a9cc6">nertc::NERtcVideoConfig::degradation_preference</a></div><div class="ttdeci">NERtcDegradationPreference degradation_preference</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:3750</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_config_html_a684048992662ab49a2f3f7ccb68da278"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_config.html#a684048992662ab49a2f3f7ccb68da278">nertc::NERtcVideoConfig::height</a></div><div class="ttdeci">uint32_t height</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:3637</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_config_html_a6af3711df481be5794c8f2d32560cd6f"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_config.html#a6af3711df481be5794c8f2d32560cd6f">nertc::NERtcVideoConfig::orientation_mode</a></div><div class="ttdeci">NERtcVideoOutputOrientationMode orientation_mode</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:3770</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_config_html_a75ec24e0422b7d565c80fb0ef00b0c2f"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_config.html#a75ec24e0422b7d565c80fb0ef00b0c2f">nertc::NERtcVideoConfig::mirror_mode</a></div><div class="ttdeci">NERtcVideoMirrorMode mirror_mode</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:3760</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_config_html_a812419614a119dad16f9d602b5ed6527"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_config.html#a812419614a119dad16f9d602b5ed6527">nertc::NERtcVideoConfig::min_framerate</a></div><div class="ttdeci">NERtcVideoFramerateType min_framerate</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:3671</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_config_html_a897f6a121362a683b40b511b779e7b1c"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_config.html#a897f6a121362a683b40b511b779e7b1c">nertc::NERtcVideoConfig::bitrate</a></div><div class="ttdeci">uint32_t bitrate</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:3730</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_config_html_ac0a1d82431926b6a8f1d9db0ad703d27"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_config.html#ac0a1d82431926b6a8f1d9db0ad703d27">nertc::NERtcVideoConfig::min_bitrate</a></div><div class="ttdeci">uint32_t min_bitrate</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:3740</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_config_html_af6b2c394608f911c4aab07df887624b7"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_config.html#af6b2c394608f911c4aab07df887624b7">nertc::NERtcVideoConfig::framerate</a></div><div class="ttdeci">NERtcVideoFramerateType framerate</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:3661</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_config_html_af8f97b4615b81e0efb7199ab3e349be1"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_config.html#af8f97b4615b81e0efb7199ab3e349be1">nertc::NERtcVideoConfig::crop_mode_</a></div><div class="ttdeci">NERtcVideoCropMode crop_mode_</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:3647</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关接口</dt><dd>若您希望为视频辅流通道设置编码属性，请调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#a92a6af7d6825b548b6a5775ceb76bc6d">setVideoConfig</a> 方法。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30005（kNERtcErrInvalidState）：引擎尚未初始化。</li>
<li>30300：Transiver 未找到。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a92a6af7d6825b548b6a5775ceb76bc6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a6af7d6825b548b6a5775ceb76bc6d">&#9670;&nbsp;</a></span>setVideoConfig() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::setVideoConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnertc_1_1_n_e_rtc_video_config.html">NERtcVideoConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置视频编码属性。 <br  />
通过此接口可以设置视频主流或辅流的编码分辨率、裁剪模式、码率、帧率、带宽受限时的视频编码降级偏好、编码的镜像模式、编码的方向模式参数。 </p><dl class="section since"><dt>自从</dt><dd>V4.6.20 </dd></dl>
<dl class="section user"><dt>调用时机 </dt><dd>请在初始化后调用该方法，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>纯音频 SDK 禁用该接口，如需使用请前往<a href="https://doc.yunxin.163.com/nertc/sdk-download" target="_blank">云信官网</a>下载并替换成视频 SDK。</li>
<li>每个属性对应一套视频参数，例如分辨率、帧率、码率等。所有设置的参数均为理想情况下的最大值。当视频引擎因网络环境等原因无法达到设置的分辨率、帧率或码率的最大值时，会取最接近最大值的那个值。</li>
<li>此接口为全量参数配置接口，重复调用此接口时，SDK 会刷新此前的所有参数配置，以最新的传参为准。所以每次修改配置时都需要设置所有参数，未设置的参数将取默认值。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>type </td><td><a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a> </td><td>视频通道类型：<ul>
<li>
kNERTCVideoStreamMain：主流。</li>
<li>
kNERTCVideoStreamSub：辅流。  </li>
</ul>
</td></tr>
<tr>
<td>config </td><td><a class="el" href="structnertc_1_1_n_e_rtc_video_config.html">NERtcVideoConfig</a> </td><td>视频编码属性配置。  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><a class="code" href="structnertc_1_1_n_e_rtc_video_config.html">nertc::NERtcVideoConfig</a> video_config_ = {};</div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#a1bb6269b9476b32a156ab3b44e89cd5c">width</a> = 1920; <span class="comment">// 编码分辨率的宽</span></div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#a684048992662ab49a2f3f7ccb68da278">height</a> = 1080; <span class="comment">// 编码分辨率的高</span></div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#a75ec24e0422b7d565c80fb0ef00b0c2f">mirror_mode</a> = <a class="code" href="namespacenertc.html#aa3abbd3e5bbe492f54f9720d0b25d3f8a35100cf833e23603ab1a6170bf1c1683">nertc::kNERtcVideoMirrorModeAuto</a>; <span class="comment">// 视频镜像模式</span></div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#a6af3711df481be5794c8f2d32560cd6f">orientation_mode</a> = <a class="code" href="namespacenertc.html#aaa3dc5429ed6cb20020bced1c471ee7ea5e54f9567613901010475d0b0fd35e6d">nertc::kNERtcVideoOutputOrientationModeAdaptative</a>; <span class="comment">// 视频旋转的方向模式。</span></div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#a04fcd6d449dcacbd7818fdce480c1bd5">max_profile</a> = <a class="code" href="namespacenertc.html#a80b32c4c5cf6f4a36dbe6650ae859058a697f9e8e70fedcdc77404aae13afe4b9">nertc::kNERtcVideoProfileHD1080P</a>; <span class="comment">// 视频编码配置</span></div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#af8f97b4615b81e0efb7199ab3e349be1">crop_mode_</a> = <a class="code" href="namespacenertc.html#a350c51e2dbbe98fa1891f1ae1760d560a7fa7a12fd9e1189ec059bd26bbb4cd0c">nertc::kNERtcVideoCropModeDefault</a>;<span class="comment">//裁剪模式</span></div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#a897f6a121362a683b40b511b779e7b1c">bitrate</a> = 0; <span class="comment">// 视频编码的码率</span></div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#ac0a1d82431926b6a8f1d9db0ad703d27">min_bitrate</a> = 0;<span class="comment">//视频编码的最小码率</span></div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#af6b2c394608f911c4aab07df887624b7">framerate</a> = 30; <span class="comment">// 视频编码的帧率</span></div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#a812419614a119dad16f9d602b5ed6527">min_framerate</a> = 2;<span class="comment">// 视频编码的最小帧率</span></div>
<div class="line">video_config_.<a class="code" href="structnertc_1_1_n_e_rtc_video_config.html#a68247fbaffa5ce83a7f7185e743a9cc6">degradation_preference</a> = <a class="code" href="namespacenertc.html#a41cbc2850e52d1bcd3ba36dc3aff7eb1a126647a2e99c1caa5cfa8e5a45741c67">nertc::kNERtcDegradationDefault</a>;<span class="comment">// 带宽受限时的视频编码降级偏好</span></div>
<div class="line">rtc_channel_-&gt;setVideoConfig(<a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a15fcc7ab62484b7ed86661f6e7188a09">nertc::kNERTCVideoStreamMain</a>, video_config_);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30005（kNERtcErrInvalidState）：引擎尚未初始化。</li>
<li>30300：Transiver 未找到。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac4a5ad482b2ec85cb76767f05ef072dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a5ad482b2ec85cb76767f05ef072dd">&#9670;&nbsp;</a></span>startChannelMediaRelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::startChannelMediaRelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnertc_1_1_n_e_rtc_channel_media_relay_configuration.html">NERtcChannelMediaRelayConfiguration</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>开始跨房间媒体流转发。</p><ul>
<li>该方法可用于实现跨房间连麦等场景。支持同时转发到 4 个房间，同一个房间可以有多个转发进来的媒体流。</li>
<li>成功调用该方法后，SDK 会触发 <code>onMediaRelayStateChanged</code> 和 <code>onMediaRelayEvent</code> 回调，并在回调中报告当前的跨房间媒体流转发状态和事件。 <dl class="section note"><dt>注解</dt><dd></dd></dl>
</li>
<li>请在成功加入房间后调用该方法。调用此方法前需要通过 <code><a class="el" href="structnertc_1_1_n_e_rtc_channel_media_relay_configuration.html">NERtcChannelMediaRelayConfiguration</a></code> 中的 <code>dest_infos</code> 设置目标房间。</li>
<li>该方法仅对直播场景下的主播角色有效。</li>
<li>成功调用该方法后，若您想再次调用该方法，必须先调用 <code>stopChannelMediaRelay</code> 方法退出当前的转发状态。</li>
<li>成功开始跨房间转发媒体流后，如果您需要修改目标房间，例如添加或删减目标房间等，可以调用方法 <code>updateChannelMediaRelay</code> 更新目标房间信息。 <dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>跨房间媒体流转发参数配置信息。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功返回0，其他则失败 </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a44615af019e079d240ed1f32d8348f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44615af019e079d240ed1f32d8348f11">&#9670;&nbsp;</a></span>startScreenCaptureByDisplayId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::startScreenCaptureByDisplayId </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>display_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnertc_1_1_n_e_rtc_rectangle.html">NERtcRectangle</a> &amp;&#160;</td>
          <td class="paramname"><em>region_rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnertc_1_1_n_e_rtc_screen_capture_parameters.html">NERtcScreenCaptureParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>capture_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过指定屏幕 ID 开启屏幕共享，屏幕共享内容以辅流形式发送。 <br  />
此方法调用成功后，远端触发 onUserSubStreamVideoStart 回调。 </p><dl class="section note"><dt>注解</dt><dd><ul>
<li>该方法仅适用于 macOS。Windows 平台请使用方法 startScreenCaptureByScreenRect。</li>
<li>该方法需要在加入房间后设置。 </li>
</ul>
</dd></dl>
<dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">display_id</td><td>指定待共享的屏幕 ID。开发者需要自行实现枚举屏幕 ID 的方法，并通过该参数指定需要共享的屏幕。 </td></tr>
    <tr><td class="paramname">region_rect</td><td>指定待共享的区域相对于整个窗口的位置。如果设置的共享区域超出了窗口的边界，则只共享窗口内的内容；如果宽或高为 0，则共享整个窗口。 </td></tr>
    <tr><td class="paramname">capture_params</td><td>屏幕共享的参数配置，包括码率、帧率、编码策略、屏蔽窗口列表等。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功；</li>
<li>其他: 方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="acd4ae2daa7bec91cc8e3cdafbcb95529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4ae2daa7bec91cc8e3cdafbcb95529">&#9670;&nbsp;</a></span>startScreenCaptureByScreenRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::startScreenCaptureByScreenRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnertc_1_1_n_e_rtc_rectangle.html">NERtcRectangle</a> &amp;&#160;</td>
          <td class="paramname"><em>screen_rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnertc_1_1_n_e_rtc_rectangle.html">NERtcRectangle</a> &amp;&#160;</td>
          <td class="paramname"><em>region_rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnertc_1_1_n_e_rtc_screen_capture_parameters.html">NERtcScreenCaptureParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>capture_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>开启屏幕共享，共享范围为指定屏幕的指定区域。 <br  />
调用该方法时，可以选择共享整个虚拟屏、指定屏幕，或虚拟屏、整个屏幕的某些区域范围。 <br  />
此方法调用成功后，远端触发 onUserSubStreamVideoStart 和 setExcludeWindowList 回调。 </p><dl class="section note"><dt>注解</dt><dd><ul>
<li>该方法仅适用于 Windows。macOS 平台请使用方法 startScreenCaptureByDisplayId。</li>
<li>该方法需要在加入房间后调用。 </li>
</ul>
</dd></dl>
<dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">screen_rect</td><td>指定待共享的屏幕相对于虚拟屏的位置。 </td></tr>
    <tr><td class="paramname">region_rect</td><td>指定待共享区域相对于整个屏幕屏幕的位置。如果设置的共享区域超出了屏幕的边界，则只共享屏幕内的内容；如果将 width 或 height 设为 0, 则共享整个屏幕。 </td></tr>
    <tr><td class="paramname">capture_params</td><td>屏幕共享的编码参数配置。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功；</li>
<li>其他: 方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a53cc3d908fed71815a7a29339215e5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53cc3d908fed71815a7a29339215e5ea">&#9670;&nbsp;</a></span>startScreenCaptureByWindowId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::startScreenCaptureByWindowId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a93322486d4e060256d5bff61c75fad53">source_id_t</a>&#160;</td>
          <td class="paramname"><em>window_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnertc_1_1_n_e_rtc_rectangle.html">NERtcRectangle</a> &amp;&#160;</td>
          <td class="paramname"><em>region_rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnertc_1_1_n_e_rtc_screen_capture_parameters.html">NERtcScreenCaptureParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>capture_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过指定窗口 ID 开启屏幕共享，屏幕共享内容以辅流形式发送。 <br  />
调用该方法时需要指定待共享的屏幕 ID，共享该屏幕的整体画面或指定区域。 <br  />
此方法调用成功后：</p><ul>
<li>Windows 平台远端触发 onUserSubStreamVideoStop 和 onScreenCaptureStatus 回调。</li>
<li>macOS 平台远端触发 onUserSubStreamVideoStop 回调。 <dl class="section note"><dt>注解</dt><dd></dd></dl>
</li>
<li>该方法适用于 Windows 和 macOS。</li>
<li>该方法需要在加入房间后调用。 <dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">window_id</td><td>指定待共享的窗口 ID。 </td></tr>
    <tr><td class="paramname">region_rect</td><td>指定待共享的区域相对于整个窗口的位置。如果设置的共享区域超出了窗口的边界，则只共享指定区域中窗口内的内容；如果宽或高为 0，则共享整个窗口。 </td></tr>
    <tr><td class="paramname">capture_params</td><td>屏幕共享的参数配置，包括码率、帧率、编码策略、屏蔽窗口列表等。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd></dd></dl>
</li>
<li>0: 方法调用成功；</li>
<li>其他: 方法调用失败。 </li>
</ul>

</div>
</div>
<a id="a0e4dde6895c937eac0b88a852a90796d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4dde6895c937eac0b88a852a90796d">&#9670;&nbsp;</a></span>stopChannelMediaRelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::stopChannelMediaRelay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>停止跨房间媒体流转发。 <br  />
 通常在主播离开房间时，跨房间媒体流转发会自动停止；您也可以根据需要随时调用该方法，此时主播会退出所有目标房间。 </p><dl class="section since"><dt>自从</dt><dd>V4.3.0 </dd></dl>
<dl class="section user"><dt>使用前提</dt><dd>请在调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#ac4a5ad482b2ec85cb76767f05ef072dd">startChannelMediaRelay</a> 方法开启跨房间媒体流转发之后调用此接口。 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化之后调用此接口，且该方法仅可在加入房间后调用。 </dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line">rtc_channel_-&gt;stopChannelMediaRelay();</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd><a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#afed841228fb61d9de7eeb21a0a86b7ce">onMediaRelayStateChanged</a>：跨房间媒体流转发状态发生改变回调。成功调用该方法后会返回 MEDIARELAY_STATE_IDLE，否则会返回 MEDIARELAY_STATE_FAILURE。 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a3df6628b686f773f6ece082cbeefe6db">onMediaRelayEvent</a>：跨房间媒体流相关转发事件回调。成功调用该方法后会返回 MEDIARELAY_EVENT_DISCONNECT，否则会返回 MEDIARELAY_EVENT_FAILURE。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa338cffad6abd1cd31f6a9ab0a2e5ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa338cffad6abd1cd31f6a9ab0a2e5ed1">&#9670;&nbsp;</a></span>stopScreenCapture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::stopScreenCapture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>关闭屏幕共享。 <br  />
 通过此接口可以实现关闭屏幕共享辅流。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化之后调用此接口，且该方法仅可在加入房间后调用。 </dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line">rtc_channel_-&gt;stopScreenCapture();</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd>成功调用此方法后，本端会触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a4f99a2c5a8c4250737100550ae3a397c">onScreenCaptureStatus</a> 回调（仅 Windwos 平台），远端会触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a42b9fd5c977fd42ca91f8625b08170d5">onUserSubStreamVideoStop</a> 回调。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30005（kNERtcErrInvalidState）：引擎未初始化或未开启屏幕共享。</li>
<li>30022（kErrorDesktopCaptureNotReady）：未找到正在共享目标源或未开启屏幕共享。</li>
<li>30101（kErrorRoomNotJoined）：未加入房间。</li>
<li>30200（kErrorConnectionNotFound）：未找到信令连接。</li>
<li>30203（kErrorTrackNotFound）：轨道错误。</li>
<li>30300（kErrorTransceiverNotFound）：收发器错误。</li>
<li>30400（kErrorRtcRoomNotFound）：未找到对应房间。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0784ea010737d143f34df789dcd051e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0784ea010737d143f34df789dcd051e2">&#9670;&nbsp;</a></span>subscribeAllRemoteAudioStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::subscribeAllRemoteAudioStream </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subscribe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>取消或恢复订阅所有远端用户的音频主流。 <br  />
加入房间时，默认订阅所有远端用户的音频主流，即 <a class="el" href="classnertc_1_1_i_rtc_engine_ex.html#a4d39a81643f19979461ec0bb569f4a0d">setParameters</a> 方法的 KEY_AUTO_SUBSCRIBE_AUDIO 参数默认设置为 true；只有当该参数的设置为 false 时，此接口的调用才会生效。 </p><dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化之后调用此接口，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section user"><dt>业务场景</dt><dd>适用于重要会议需要一键全体静音的场景。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>设置该方法的 subscribe 参数为 true 后，对后续加入房间的用户同样生效。</li>
<li>在开启自动订阅（默认）时，设置该方法的 subscribe 参数为 false 可以实现取消订阅所有远端用户的音频流，但此时无法再调用 <a class="el" href="classnertc_1_1_i_rtc_engine_ex.html#acfd7cd68d15239591ccfd251d4ed53b3">subscribeRemoteAudioStream</a> 方法单独订阅指定远端用户的音频流。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>subscribe </td><td>bool </td><td>是否订阅所有用户的音频主流：<ul>
<li>
true：订阅音频主流。</li>
<li>
false：取消订阅音频主流。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//订阅所有远端用户的音频主流</span></div>
<div class="line">rtc_channel_-&gt;subscribeAllRemoteAudioStream(<span class="keyword">true</span>);</div>
<div class="line"><span class="comment">//取消订阅所有远端用户的音频主流</span></div>
<div class="line">rtc_channel_-&gt;subscribeAllRemoteAudioStream(<span class="keyword">false</span>);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30005（kNERtcErrInvalidState)：引擎未初始化。</li>
<li>30026：ASL 选路功能启用失败。</li>
<li>30400：Transceiver 未找到。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5a98f198738b466f36fadfb26035baa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a98f198738b466f36fadfb26035baa7">&#9670;&nbsp;</a></span>subscribeRemoteAudioStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::subscribeRemoteAudioStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a>&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subscribe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>取消或恢复订阅所有远端用户的音频主流。 <br  />
加入房间时，默认订阅所有远端用户的音频主流，即 <a class="el" href="classnertc_1_1_i_rtc_engine_ex.html#a4d39a81643f19979461ec0bb569f4a0d">setParameters</a> 方法的 KEY_AUTO_SUBSCRIBE_AUDIO 参数默认设置为 true；只有当该参数的设置为 false 时，此接口的调用才会生效。 </p><dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化之后调用此接口，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section user"><dt>业务场景</dt><dd>适用于重要会议需要一键全体静音的场景。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>设置该方法的 subscribe 参数为 true 后，对后续加入房间的用户同样生效。 在开启自动订阅（默认）时，设置该方法的 subscribe 参数为 false 可以实现取消订阅所有远端用户的音频流，但此时无法再调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#a5a98f198738b466f36fadfb26035baa7">subscribeRemoteAudioStream</a> 方法单独订阅指定远端用户的音频流。 </dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>subscribe </td><td>bool </td><td>是否订阅所有用户的音频主流：<ul>
<li>
true：订阅音频主流。</li>
<li>
false：取消订阅音频主流。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//订阅所有远端用户的音频主流</span></div>
<div class="line">rtc_channel_-&gt;subscribeAllRemoteAudioStream(<span class="keyword">true</span>);</div>
<div class="line"><span class="comment">//取消订阅所有远端用户的音频主流</span></div>
<div class="line">rtc_channel_-&gt;subscribeAllRemoteAudioStream(<span class="keyword">false</span>);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30005（kNERtcErrInvalidState）：引擎尚未初始化或尚未加入房间。</li>
<li>30008（kNERtcErrDeviceNotFound：设备未找到。</li>
<li>30015（kNERtcErrConnectFail )：服务器连接错误。</li>
<li>30101（kNERtcErrChannelNotJoined)：尚未加入房间。</li>
<li>30105（kNERtcErrUserNotFound）：未找到指定用户。</li>
<li>30106（kNERtcErrInvalidUserID）：非法指定用户，比如订阅了本端。</li>
<li>30200（kNERtcErrConnectionNotFound）：未连接成功。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad7907c459ccb5278fc3adfc685afe5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7907c459ccb5278fc3adfc685afe5b4">&#9670;&nbsp;</a></span>subscribeRemoteSubStreamAudio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::subscribeRemoteSubStreamAudio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a>&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subscribe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置是否订阅指定远端用户的音频辅流。 </p><dl class="section since"><dt>自从</dt><dd>V4.6.10 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化之后调用此接口，且该方法仅可在加入房间且收到远端用户开启音频辅流的回调 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a69a40ccee6764c01482f5eab32db9e57">onUserSubStreamAudioStart</a> 后调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>加入房间时，默认订阅所有远端用户的音频流。</li>
<li>请在指定远端用户加入房间后再调用此方法。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明 </dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>uid </td><td>uid_t </td><td>远端用户 ID。  </td></tr>
<tr>
<td>subscribe </td><td>bool </td><td>是否订阅指定音频辅流：<ul>
<li>
true：订阅指定音频辅流。</li>
<li>
false：取消订阅指定音频辅流。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//订阅对方音频辅流</span></div>
<div class="line">rtc_channel_-&gt;subscribeRemoteSubStreamAudio(uid, <span class="keyword">true</span>);</div>
<div class="line"><span class="comment">//取消订阅对方音频辅流</span></div>
<div class="line">rtc_channel_-&gt;subscribeRemoteSubStreamAudio(uid, <span class="keyword">false</span>);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30005（kNERtcErrInvalidState）：状态错误，比如引擎未初始化。</li>
<li>30101（kNERtcErrChannelNotJoined)：尚未加入房间。</li>
<li>30105（kNERtcErrUserNotFound）：指定用户尚未加入房间。</li>
<li>30106（kNERtcErrInvalidUserID）：非法的用户 ID。</li>
<li>30200（kNERtcErrConnectionNotFound）：媒体会话未建立，比如指定用户尚未发布音频辅流。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a28d5217a88d92f69948c3fa1da425387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d5217a88d92f69948c3fa1da425387">&#9670;&nbsp;</a></span>subscribeRemoteVideoStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::subscribeRemoteVideoStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a>&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#af9a1648ac76c0c9682bdadeca2f5c80d">NERtcRemoteVideoStreamType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subscribe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>订阅或取消订阅指定远端用户的视频主流。 <br  />
加入房间后，默认不订阅所有远端用户的视频主流；若您希望看到指定远端用户的视频，可以在监听到对方加入房间或发布视频流之后，通过此方法订阅该用户的视频主流。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在初始化后调用该方法，且该方法仅可在加入房间后调用。 </dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>uid </td><td>uid_t </td><td>指定用户的 ID。  </td></tr>
<tr>
<td>streamType </td><td><a class="el" href="namespacenertc.html#af9a1648ac76c0c9682bdadeca2f5c80d">NERtcRemoteVideoStreamType</a> </td><td>订阅的视频流类型：<ul>
<li>
kNERtcRemoteVideoStreamTypeHigh：高清画质的大流。</li>
<li>
kNERtcRemoteVideoStreamTypeLow：低清画质的小流。</li>
<li>
kNERtcRemoteVideoStreamTypeNone：不订阅。  </li>
</ul>
</td></tr>
<tr>
<td>subscribe </td><td>bool </td><td>是否订阅远端用户的视频流：<ul>
<li>
true：订阅指定视频流。</li>
<li>
false：不订阅指定视频流。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//订阅对方uid为12345的大流</span></div>
<div class="line">rtc_channel_-&gt;subscribeRemoteVideoStream(12345, <a class="code" href="namespacenertc.html#af9a1648ac76c0c9682bdadeca2f5c80da90daeee06a77341e057f4d698820f8c7">nertc::kNERtcRemoteVideoStreamTypeHigh</a>,<span class="keyword">true</span>);</div>
<div class="ttc" id="anamespacenertc_html_af9a1648ac76c0c9682bdadeca2f5c80da90daeee06a77341e057f4d698820f8c7"><div class="ttname"><a href="namespacenertc.html#af9a1648ac76c0c9682bdadeca2f5c80da90daeee06a77341e057f4d698820f8c7">nertc::kNERtcRemoteVideoStreamTypeHigh</a></div><div class="ttdeci">@ kNERtcRemoteVideoStreamTypeHigh</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:1707</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关接口</dt><dd>若您希望订阅指定远端用户的视频辅流，请调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#aced63407cd6d002c598585240ee0fe60">subscribeRemoteVideoSubStream</a>} 方法。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30001（kNERtcErrFatal）：画布为空对象，创建远端 peerconnection 失败。</li>
<li>30005（kNERtcErrInvalidState)：状态错误，比如引擎尚未初始化。</li>
<li>30009（kNERtcErrInvalidDeviceSourceID）：设备 ID 非法。</li>
<li>30105（kNERtcErrUserNotFound）：未找到指定用户。</li>
<li>30106（kNERtcErrInvalidUserID）：非法指定用户，比如订阅了本端。</li>
<li>30107（kNERtcErrMediaNotStarted）：媒体会话未建立，比如对端未开启视频主流。</li>
<li>30108（kNERtcErrSourceNotFound）：媒体源未找到，比如对端未开启视频主流。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="aced63407cd6d002c598585240ee0fe60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced63407cd6d002c598585240ee0fe60">&#9670;&nbsp;</a></span>subscribeRemoteVideoSubStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::subscribeRemoteVideoSubStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a>&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subscribe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>订阅或取消订阅远端用户的视频辅流。 </p><dl class="section since"><dt>自从</dt><dd>V3.9.0 </dd></dl>
<dl class="section user"><dt>使用前提</dt><dd><ul>
<li>请先调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#a6d6767fcbb866ec12dc1ee274f87c1c3">setupRemoteSubStreamVideoCanvas</a> 设置远端用户的视频辅流画布。</li>
<li>建议在收到远端用户发布视频辅流的回调通知 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a10db6c8490799f3c1229265801faf477">onUserSubStreamVideoStart</a> 后调用此接口。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化之后调用此接口，且该方法仅可在加入房间后调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>纯音频 SDK 禁用该接口，如需使用请前往云信官网下载并替换成视频 SDK。 </dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>uid </td><td>uid_t </td><td>远端用户 ID。  </td></tr>
<tr>
<td>subsribe </td><td>bool </td><td>是否订阅远端的视频辅流：<ul>
<li>
true：订阅远端视频辅流。</li>
<li>
false：取消订阅远端视频辅流。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="keywordflow">if</span>(rtc_channel_) {</div>
<div class="line"><a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html">nertc::NERtcVideoCanvas</a> canvas;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#ab75d8766a11caf1be65102a7639a5c2c">window</a> = window;</div>
<div class="line">rtc_channel_-&gt;setupRemoteSubStreamVideoCanvas(uid, canvas);</div>
<div class="line">rtc_channel_-&gt;subscribeRemoteVideoSubStream(uid, <span class="keyword">true</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd><ul>
<li><a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a10db6c8490799f3c1229265801faf477">onUserSubStreamVideoStart</a> ：远端用户发布视频辅流的回调。</li>
<li><a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a42b9fd5c977fd42ca91f8625b08170d5">onUserSubStreamVideoStop</a>：远端用户停止发布视频辅流的回调。 </li>
</ul>
</dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30004（kNERtcErrNotSupported）：不支持的操作。</li>
<li>30005（kNERtcErrInvalidState）：当前状态不支持的操作，比如引擎尚未初始化。</li>
<li>30105（kNERtcErrUserNotFound）：未找到该远端用户，可能对方还未加入房间。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a605e0480cb41fcc692f5eb6b1ca28cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605e0480cb41fcc692f5eb6b1ca28cb9">&#9670;&nbsp;</a></span>takeLocalSnapshot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::takeLocalSnapshot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a>&#160;</td>
          <td class="paramname"><em>stream_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnertc_1_1_n_e_rtc_take_snapshot_callback.html">NERtcTakeSnapshotCallback</a> *&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>本地视频画面截图。 <br  />
调用 takeLocalSnapshot 截取本地主流或本地辅流的视频画面，并通过 <a class="el" href="classnertc_1_1_n_e_rtc_take_snapshot_callback.html">NERtcTakeSnapshotCallback::onTakeSnapshotResult</a> 回调返回截图画面的数据。 </p><dl class="section note"><dt>注解</dt><dd><ul>
<li>本地主流截图，需要在 startPreview 或者 enableLocalVideo 并 joinChannel 成功之后调用。</li>
<li>本地辅流截图，需要在 startScreenCapture 并 joinChannel 成功之后调用。</li>
<li>同时设置文字、时间戳或图片水印时，如果不同类型的水印位置有重叠，会按照图片、文本、时间戳的顺序进行图层覆盖。 </li>
</ul>
</dd></dl>
<dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream_type</td><td>截图的视频流类型。支持设置为主流或辅流。详细信息请参考 <a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a> 。 </td></tr>
    <tr><td class="paramname">callback</td><td>截图回调。详细信息请参考 <a class="el" href="classnertc_1_1_n_e_rtc_take_snapshot_callback.html">NERtcTakeSnapshotCallback</a> 。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功；</li>
<li>其他: 方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af85102b0bc44d35050693eeea4c9f79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85102b0bc44d35050693eeea4c9f79f">&#9670;&nbsp;</a></span>takeRemoteSnapshot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::takeRemoteSnapshot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a>&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a>&#160;</td>
          <td class="paramname"><em>stream_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnertc_1_1_n_e_rtc_take_snapshot_callback.html">NERtcTakeSnapshotCallback</a> *&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>远端视频画面截图。 <br  />
调用 takeRemoteSnapshot 截取指定 uid 远端主流和远端辅流的视频画面，并通过 <a class="el" href="classnertc_1_1_n_e_rtc_take_snapshot_callback.html">NERtcTakeSnapshotCallback::onTakeSnapshotResult</a> 回调返回截图画面的数据。 </p><dl class="section note"><dt>注解</dt><dd><ul>
<li>takeRemoteSnapshot 需要在收到 onUserVideoStart 与 onUserSubStreamVideoStart 回调之后调用。</li>
<li>同时设置文字、时间戳或图片水印时，如果不同类型的水印位置有重叠，会按照图片、文本、时间戳的顺序进行图层覆盖。 </li>
</ul>
</dd></dl>
<dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">uid</td><td>远端用户 ID。 </td></tr>
    <tr><td class="paramname">stream_type</td><td>截图的视频流类型。支持设置为主流或辅流。详细信息请参考 <a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a> 。 </td></tr>
    <tr><td class="paramname">callback</td><td>截图回调。详细信息请参考 <a class="el" href="classnertc_1_1_n_e_rtc_take_snapshot_callback.html">NERtcTakeSnapshotCallback</a> 。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功；</li>
<li>其他: 方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ade5d3a58a6fa18a2e43c6b7cc3537fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5d3a58a6fa18a2e43c6b7cc3537fe2">&#9670;&nbsp;</a></span>updateChannelMediaRelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::updateChannelMediaRelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnertc_1_1_n_e_rtc_channel_media_relay_configuration.html">NERtcChannelMediaRelayConfiguration</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>更新媒体流转发的目标房间。 <br  />
成功开始跨房间转发媒体流后，如果你希望将流转发到多个目标房间，或退出当前的转发房间，可以调用该方法。</p><ul>
<li>成功开始跨房间转发媒体流后，如果您需要修改目标房间，例如添加或删减目标房间等，可以调用此方法。</li>
<li>成功调用该方法后，SDK 会触发 <code>onMediaRelayStateChange</code> 和 <code>onMediaRelayEvent</code> 回调，并在回调中报告当前的跨房间媒体流转发状态和事件。 <dl class="section note"><dt>注解</dt><dd>请在加入房间并成功调用 <code>startChannelMediaRelay</code> 开始跨房间媒体流转发后，调用此方法。调用此方法前需要通过 <code><a class="el" href="structnertc_1_1_n_e_rtc_channel_media_relay_configuration.html">NERtcChannelMediaRelayConfiguration</a></code> 中的 <code>dest_infos</code> 设置目标房间。 </dd></dl>
<dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>目标房间配置信息 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功返回0，其他则失败 </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a2570d5b8ed903d0bd086a619f4c84fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2570d5b8ed903d0bd086a619f4c84fe5">&#9670;&nbsp;</a></span>updateLiveStreamTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::updateLiveStreamTask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnertc_1_1_n_e_rtc_live_stream_task_info.html">NERtcLiveStreamTaskInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>更新房间内指定推流任务。 通过此接口可以实现调整指定推流任务的编码参数、画布布局、推流模式等。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>使用前提</dt><dd>请先调用 <a class="el" href="classnertc_1_1_i_rtc_channel.html#a3fd04f5c8c7733bc661ba32137e978e9">addLiveStreamTask</a>} 方法添加推流任务。 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化之后调用此接口，且该方法仅可在加入房间后调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>仅角色为主播的房间成员能调用此接口，观众成员无相关推流权限。 </dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>info </td><td><a class="el" href="structnertc_1_1_n_e_rtc_live_stream_task_info.html">NERtcLiveStreamTaskInfo</a> </td><td>推流任务信息。  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="keywordflow">if</span> (rtc_channel_) {</div>
<div class="line">    <span class="keywordflow">return</span> rtc_channel_-&gt;updateLiveStreamTask(info);</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd><a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a5a919dcba8cf248a22c583640b843012">onUpdateLiveStreamTask</a>：推流任务已成功更新回调。 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a16bf1ed05a44102458c587bc59cb140f">onAddLiveStreamTask</a>：推流任务状态已改变回调。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功；</li>
<li>其他：方法调用失败。<ul>
<li>403（kNERtcErrChannelReservePermissionDenied）：权限不足，观众模式下不支持此操作。</li>
<li>30005（kNERtcErrInvalidState）：当前状态不支持的操作，比如引擎尚未初始化。</li>
<li>30101（kNERtcErrChannelNotJoined）：尚未加入房间。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab75a680086ecade7d05f971e516409c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75a680086ecade7d05f971e516409c4">&#9670;&nbsp;</a></span>updatePermissionKey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::updatePermissionKey </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>更新权限密钥。</p><ul>
<li>通过本接口可以实现当用户权限被变更，或者收到权限密钥即将过期的回调 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a5b22cfbb8a3717db2dad821669bbaee4">onPermissionKeyWillExpire</a> 时，更新权限密钥。 <dl class="section since"><dt>自从</dt><dd>V4.6.29 </dd></dl>
<dl class="section user"><dt>使用前提</dt><dd>请确保已开通高级 Token 鉴权功能，具体请联系网易云信商务经理。 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化之后调用此接口，且该方法仅可在加入房间后调用。 </dd></dl>
<dl class="section user"><dt>业务场景</dt><dd>适用于变更指定用户加入、创建房间或上下麦时发布流相关权限的场景。 </dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>key </td><td>const char* </td><td>新的权限密钥。  </td></tr>
</table>
<br  />
 </dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="keywordflow">if</span> (rtc_channel_) {</div>
<div class="line">std::string key;<span class="comment">//向服务器请求得到的权限key，具体请参考官方文档的高级 Token 鉴权章节。&lt;/a&gt;</span></div>
<div class="line">res = rtc_channel_-&gt;updatePermissionKey(key.c_str()));</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="namespacenertc.html#af062cfe332d58922ac8c020d55f9bb17a4557f34a02a4664f885d3bc329114b1b">kNERtcNoError</a> != res) {</div>
<div class="line">}</div>
<div class="ttc" id="anamespacenertc_html_af062cfe332d58922ac8c020d55f9bb17a4557f34a02a4664f885d3bc329114b1b"><div class="ttname"><a href="namespacenertc.html#af062cfe332d58922ac8c020d55f9bb17a4557f34a02a4664f885d3bc329114b1b">nertc::kNERtcNoError</a></div><div class="ttdeci">@ kNERtcNoError</div><div class="ttdef"><b>Definition:</b> nertc_error_code.h:35</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd>调用此接口成功更新权限密钥后会触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#aeaa93253548efdd63fffe13f60093477">onUpdatePermissionKey</a> 回调。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd></dd></dl>
</li>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30003（kNERtcErrInvalidParam）：参数错误，比如 key 无效。</li>
<li>30005（kNERtcErrInvalidState)：当前状态不支持的操作，比如引擎尚未初始化。 </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a6b3b133b7f0d76965eb098f895a69814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3b133b7f0d76965eb098f895a69814">&#9670;&nbsp;</a></span>updateScreenCaptureParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::updateScreenCaptureParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnertc_1_1_n_e_rtc_screen_capture_parameters.html">nertc::NERtcScreenCaptureParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>captureParams</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>更新屏幕共享参数。 <br  />
开始共享屏幕或窗口后，动态更新采集帧率，目标码率，编码分辨率等屏幕共享相关参数。 </p><dl class="section since"><dt>自从</dt><dd>V4.6.20 </dd></dl>
<dl class="section user"><dt>调用时机 </dt><dd>请在加入房间并成功开启屏幕共享后调用该方法。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>调用该方法会重新启动屏幕共享，因此建议不要频繁调用。</li>
<li>可以通过该方法动态设置是否捕捉鼠标（capture_mouse_cursor）和设置排除窗口（excluded_window_list，excluded_window_count），同时这两项设置也可以通过 <a class="el" href="classnertc_1_1_i_rtc_engine_ex.html#a05fddbeddc5f4d542bf4213cd9f08a06">setScreenCaptureMouseCursor</a> 和 <a class="el" href="classnertc_1_1_i_rtc_engine_ex.html#af8f973d982c661f15c306758f5cc7bbb">setExcludeWindowList</a> 方法实现。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明 </dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>captureParams </td><td><a class="el" href="structnertc_1_1_n_e_rtc_screen_capture_parameters.html">NERtcScreenCaptureParameters</a> </td><td>屏幕共享编码参数配置。  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//调用该方法时，需要维护一个 nertc::NERtcScreenCaptureParameters captureParams 变量记录当前设置。更新设置的时候：</span></div>
<div class="line"><a class="code" href="structnertc_1_1_n_e_rtc_screen_capture_parameters.html">nertc::NERtcScreenCaptureParameters</a> captureParams;</div>
<div class="line">captureParams.field1 = new_value1;</div>
<div class="line">captureParams.field2 = new_value2;</div>
<div class="line">...</div>
<div class="line">rtc_channel-&gt;updateScreenCaptureParameters(captureParams);</div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_screen_capture_parameters_html"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_screen_capture_parameters.html">nertc::NERtcScreenCaptureParameters</a></div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:4094</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd>成功调用该方法后，会触发 <a class="el" href="classnertc_1_1_i_rtc_channel_event_handler.html#a4f99a2c5a8c4250737100550ae3a397c">onScreenCaptureStatus</a> 回调。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30005（kErrorErrInvalidState）：多房间状态错误。</li>
<li>30021（kNERtcErrDesktopCaptureInvalidParam）：传入的参数无效。</li>
<li>30101（kNERtcErrChannelNotJoined）：未加入房间。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae0e9d14fd2c5db3b1544f18a5bb67a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e9d14fd2c5db3b1544f18a5bb67a02">&#9670;&nbsp;</a></span>updateScreenCaptureRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::updateScreenCaptureRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnertc_1_1_n_e_rtc_rectangle.html">NERtcRectangle</a> &amp;&#160;</td>
          <td class="paramname"><em>region_rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在共享屏幕或窗口时，更新共享的区域。 <br  />
在 Windows 平台中，远端会触发 onScreenCaptureStatus 回调。 </p><dl class="section since"><dt>自从</dt><dd>V4.5.0 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">region_rect</td><td>指定待共享的区域相对于整个窗口或屏幕的位置。如果设置的共享区域超出了边界，则只共享指定区域中，窗口或屏幕内的内容；如果宽或高为 0，则共享整个窗口或屏幕。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功。</li>
<li>其他: 方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8a4e7c404d47e33f4a1cbff1f1284dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4e7c404d47e33f4a1cbff1f1284dfb">&#9670;&nbsp;</a></span>updateSelfPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcChannel::updateSelfPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnertc_1_1_n_e_rtc_position_info.html">NERtcPositionInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>更新本地用户的空间位置。 </p><dl class="section since"><dt>自从</dt><dd>V5.5.10 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化后调用此接口，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section user"><dt>参数说明</dt><dd>通过 info 参数设置空间音效中说话者和接收者的空间位置信息。 <a class="el" href="structnertc_1_1_n_e_rtc_position_info.html">NERtcPositionInfo</a> 的具体参数说明如下表所示。 <table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>speaker_position </td><td>说话者的位置信息，三个值依次表示X、Y、Z的坐标值。默认值{0,0,0}   </td></tr>
<tr>
<td>speaker_quaternion </td><td>说话者的旋转信息，通过四元组来表示，数据格式为{w, x, y, z}。默认值{0,0,0,0}   </td></tr>
<tr>
<td>head_position </td><td>接收者的位置信息，三个值依次表示X、Y、Z的坐标值。默认值{0,0,0}   </td></tr>
<tr>
<td>head_quaternion </td><td>接收者的旋转信息，通过四元组来表示，数据格式为{w, x, y, z}。默认值{0,0,0,0}  </td></tr>
</table>
<br  />
 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功</li>
<li>其他: 调用失败 </li>
</ul>
</dd></dl>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>include/<a class="el" href="nertc__channel_8h_source.html">nertc_channel.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
