<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NERtc Windows SDK: nertc::IRtcEngine类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NERtc Windows SDK
   &#160;<span id="projectnumber">V5.5.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenertc.html">nertc</a></li><li class="navelem"><a class="el" href="classnertc_1_1_i_rtc_engine.html">IRtcEngine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="classnertc_1_1_i_rtc_engine-members.html">所有成员列表</a>  </div>
  <div class="headertitle">
<div class="title">nertc::IRtcEngine类 参考<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="nertc__engine_8h_source.html">nertc_engine.h</a>&gt;</code></p>
<div class="dynheader">
类 nertc::IRtcEngine 继承关系图:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classnertc_1_1_i_rtc_engine.png" usemap="#nertc::IRtcEngine_map" alt=""/>
  <map id="nertc::IRtcEngine_map" name="nertc::IRtcEngine_map">
<area href="classnertc_1_1_i_rtc_engine_ex.html" alt="nertc::IRtcEngineEx" shape="rect" coords="0,56,121,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a1e816fd56f1cc6953a263f6798d0f1d4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_engine.html#a1e816fd56f1cc6953a263f6798d0f1d4">initialize</a> (const <a class="el" href="structnertc_1_1_n_e_rtc_engine_context.html">NERtcEngineContext</a> &amp;context)=0</td></tr>
<tr class="separator:a1e816fd56f1cc6953a263f6798d0f1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16ff6b3517d45a9cbc1504a94770b70"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_engine.html#ac16ff6b3517d45a9cbc1504a94770b70">release</a> (bool sync=true)=0</td></tr>
<tr class="separator:ac16ff6b3517d45a9cbc1504a94770b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58ed7e0e0e4383939fc16a6a77d2570"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_engine.html#ae58ed7e0e0e4383939fc16a6a77d2570">setClientRole</a> (<a class="el" href="namespacenertc.html#a1277b5498334b7efe3ad260d72350128">NERtcClientRole</a> role)=0</td></tr>
<tr class="separator:ae58ed7e0e0e4383939fc16a6a77d2570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6195db00acf739ca2cb183015abffd5b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_engine.html#a6195db00acf739ca2cb183015abffd5b">setChannelProfile</a> (<a class="el" href="namespacenertc.html#ac30f4b7ce13da5d664df0d2a6986e940">NERtcChannelProfileType</a> profile)=0</td></tr>
<tr class="separator:a6195db00acf739ca2cb183015abffd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3f404cee7cd1b56b5019776dbb660a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_engine.html#acc3f404cee7cd1b56b5019776dbb660a">joinChannel</a> (const char *token, const char *channel_name, <a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> uid)=0</td></tr>
<tr class="separator:acc3f404cee7cd1b56b5019776dbb660a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29bdc1e3e13990b94ab9e92c8c7b5693"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_engine.html#a29bdc1e3e13990b94ab9e92c8c7b5693">joinChannel</a> (const char *token, const char *channel_name, <a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> uid, <a class="el" href="structnertc_1_1_n_e_rtc_join_channel_options.html">NERtcJoinChannelOptions</a> channel_options)=0</td></tr>
<tr class="separator:a29bdc1e3e13990b94ab9e92c8c7b5693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827ecfee86c395f564a18012fa919b59"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_engine.html#a827ecfee86c395f564a18012fa919b59">switchChannel</a> (const char *token, const char *channel_name)=0</td></tr>
<tr class="separator:a827ecfee86c395f564a18012fa919b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71d007ffe2d13a96dedcd68d7f06806"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_engine.html#ae71d007ffe2d13a96dedcd68d7f06806">switchChannel</a> (const char *token, const char *channel_name, <a class="el" href="structnertc_1_1_n_e_rtc_join_channel_options.html">NERtcJoinChannelOptions</a> channel_options)=0</td></tr>
<tr class="separator:ae71d007ffe2d13a96dedcd68d7f06806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691e74abef7cf3c41a3c8ccf8691fd40"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_engine.html#a691e74abef7cf3c41a3c8ccf8691fd40">switchChannelEx</a> (const char *token, const char *channel_name, <a class="el" href="structnertc_1_1_n_e_rtc_join_channel_options_ex.html">NERtcJoinChannelOptionsEx</a> channel_options_ex)=0</td></tr>
<tr class="separator:a691e74abef7cf3c41a3c8ccf8691fd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbc54a71986a4a4a1c9c24d2c29e884"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_engine.html#a6fbc54a71986a4a4a1c9c24d2c29e884">leaveChannel</a> ()=0</td></tr>
<tr class="separator:a6fbc54a71986a4a4a1c9c24d2c29e884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0e1e225e0fe8fc7ad1e9138d62caea"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_engine.html#a2f0e1e225e0fe8fc7ad1e9138d62caea">queryInterface</a> (<a class="el" href="namespacenertc.html#a13dd8adcb4f73bd24e37726272084a7d">NERtcInterfaceIdType</a> iid, void **inter)=0</td></tr>
<tr class="separator:a2f0e1e225e0fe8fc7ad1e9138d62caea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad602d946e22e51eb6a5fafee999ac7bd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_engine.html#ad602d946e22e51eb6a5fafee999ac7bd">enableLocalAudio</a> (bool enabled)=0</td></tr>
<tr class="separator:ad602d946e22e51eb6a5fafee999ac7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7306ae7edc1cadedceb6c2cde8df279"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_engine.html#ad7306ae7edc1cadedceb6c2cde8df279">setupLocalVideoCanvas</a> (<a class="el" href="structnertc_1_1_n_e_rtc_video_canvas.html">NERtcVideoCanvas</a> *canvas)=0</td></tr>
<tr class="separator:ad7306ae7edc1cadedceb6c2cde8df279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16192ada0272bb48adc18848e68dc57d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_engine.html#a16192ada0272bb48adc18848e68dc57d">setupRemoteVideoCanvas</a> (<a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> uid, <a class="el" href="structnertc_1_1_n_e_rtc_video_canvas.html">NERtcVideoCanvas</a> *canvas)=0</td></tr>
<tr class="separator:a16192ada0272bb48adc18848e68dc57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57782589b573cf02bbfa836dace811c1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_engine.html#a57782589b573cf02bbfa836dace811c1">enableLocalVideo</a> (bool enabled)=0</td></tr>
<tr class="separator:a57782589b573cf02bbfa836dace811c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad958fcb663c93a8c84d516effc50e863"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_engine.html#ad958fcb663c93a8c84d516effc50e863">enableLocalVideo</a> (<a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a> type, bool enabled)=0</td></tr>
<tr class="separator:ad958fcb663c93a8c84d516effc50e863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385748f3ea0003ec0eb49f925774ddac"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnertc_1_1_i_rtc_engine.html#a385748f3ea0003ec0eb49f925774ddac">subscribeRemoteVideoStream</a> (<a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a> uid, <a class="el" href="namespacenertc.html#af9a1648ac76c0c9682bdadeca2f5c80d">NERtcRemoteVideoStreamType</a> type, bool subscribe)=0</td></tr>
<tr class="separator:a385748f3ea0003ec0eb49f925774ddac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>RtcEngine 类提供了供 App 调用的主要接口方法。 <br  />
<a class="el" href="classnertc_1_1_i_rtc_engine.html">IRtcEngine</a> 是 NERTC SDK 的基础接口类。创建一个 <a class="el" href="classnertc_1_1_i_rtc_engine.html">IRtcEngine</a> 对象并调用这个对象的方法可以激活 NERTC SDK 的通信功能。 </p>
</div><h2 class="groupheader">成员函数说明</h2>
<a id="ad602d946e22e51eb6a5fafee999ac7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad602d946e22e51eb6a5fafee999ac7bd">&#9670;&nbsp;</a></span>enableLocalAudio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcEngine::enableLocalAudio </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>开启/关闭本地音频采集和发送。 <br  />
通过本接口可以实现开启或关闭本地语音功能，进行本地音频采集及处理。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化之后调用此接口，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>加入房间后，语音功能默认为开启状态。</li>
<li>该方法设置内部引擎为启用状态，在 leaveChannel 后仍然有效。</li>
<li>该方法不影响接收或播放远端音频流，enableLocalAudio(false) 适用于只下行不上行音频流的场景。</li>
<li>该方法会操作音频硬件设备，建议避免频繁开关，否则可能导致设备异常。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>enabled </td><td>boolean </td><td>是否启用本地音频的采集和发送：<ul>
<li>
true：开启本地音频采集。</li>
<li>
false：关闭本地音频采集。关闭后，远端用户会接收不到本地用户的音频流；但本地用户依然可以接收到远端用户的音频流。  </li>
</ul>
</td></tr>
</table>
<br  />
 </dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//打开音频采集</span></div>
<div class="line">rtc_engine_-&gt;enableLocalAudio(<span class="keyword">true</span>); </div>
<div class="line"><span class="comment">//关闭音频采集</span></div>
<div class="line">rtc_engine_-&gt;enableLocalAudio(<span class="keyword">false</span>);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd><ul>
<li>开启音频采集后，远端会触发 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a4e836de435599aa9a06a0bd37d16057c">onUserAudioStart</a> 回调。</li>
<li>关闭音频采集后，远端会触发 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a971392ec727e051cc2e37b8af95b6806">onUserAudioStop</a> 回调。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>相关接口</dt><dd><a class="el" href="classnertc_1_1_i_rtc_engine_ex.html#a440675d9c53376f2ed0b91b9b9a44623">muteLocalAudioStream</a>：两者的差异在于，enableLocalAudio 用于开启本地语音采集及处理，而 muteLocalAudioStream 用于停止或继续发送本地音频流。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30005（kNERtcErrInvalidState）：引擎尚未初始化，或者多房间场景下未在本房间操作。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a57782589b573cf02bbfa836dace811c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57782589b573cf02bbfa836dace811c1">&#9670;&nbsp;</a></span>enableLocalVideo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcEngine::enableLocalVideo </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>开启或关闭本地视频的采集与发送。 <br  />
通过本接口可以实现开启或关闭本地视频，不影响接收远端视频。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机 </dt><dd>请在初始化后调用该方法，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>纯音频 SDK 禁用该接口，如需使用请前往<a href="https://doc.yunxin.163.com/nertc/sdk-download" target="_blank">云信官网</a>下载并替换成视频 SDK。</li>
<li>该方法设置内部引擎为开启或关闭状态, 在 <a class="el" href="classnertc_1_1_i_rtc_engine.html#a6fbc54a71986a4a4a1c9c24d2c29e884">leaveChannel</a> 后仍然有效。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>enabled </td><td>bool </td><td>是否开启本地视频采集与发送：<ul>
<li>
true：开启本地视频采集。</li>
<li>
false：关闭本地视频采集，此时不需要本地有摄像头。关闭后，远端用户无法接收到本地用户的视频流；但本地用户仍然可以接收到远端用户的视频流。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//打开视频</span></div>
<div class="line">rtc_engine_-&gt;enableLocalVideo(<span class="keyword">true</span>);</div>
<div class="line"><span class="comment">//关闭视频</span></div>
<div class="line">rtc_engine_-&gt;enableLocalVideo(<span class="keyword">false</span>);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd><ul>
<li>开启本地视频采集后，远端会收到 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a0b84dd2fcc3a6f5fe03f36c9cc4911ad">onUserVideoStart</a> 回调。</li>
<li>关闭本地视频采集后，远端会收到 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#ac1dfb8ff38201681140c8ff7e2323bc7">onUserVideoStop</a> 回调。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>相关接口</dt><dd>若您希望开启辅流通道的视频采集，请调用 <a class="el" href="classnertc_1_1_i_rtc_engine.html#ad958fcb663c93a8c84d516effc50e863">enableLocalVideo</a> 方法。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30001（kNERtcErrFatal）：通用错误，一般表示引擎错误，尝试再次调用此接口即可。</li>
<li>30005（kNERtcErrInvalidState）：当前状态不支持的操作，比如已开启外部视频采集。</li>
<li>50000（kNERtcRuntimeErrVDMNoAuthorize）：应用未获取到操作系统的摄像头权限。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad958fcb663c93a8c84d516effc50e863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad958fcb663c93a8c84d516effc50e863">&#9670;&nbsp;</a></span>enableLocalVideo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcEngine::enableLocalVideo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>开启或关闭本地视频的采集与发送。 <br  />
通过主流或辅流视频通道进行本地视频流的采集与发送。 </p><dl class="section since"><dt>自从</dt><dd>V4.6.20 </dd></dl>
<dl class="section user"><dt>调用时机 </dt><dd>请在初始化后调用该方法，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>纯音频 SDK 禁用该接口，如需使用请前往<a href="https://doc.yunxin.163.com/nertc/sdk-download" target="_blank">云信官网</a>下载并替换成视频 SDK。</li>
<li>该方法设置内部引擎为开启或关闭状态, 在 <a class="el" href="classnertc_1_1_i_rtc_engine.html#a6fbc54a71986a4a4a1c9c24d2c29e884">leaveChannel</a> 后仍然有效。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>type </td><td><a class="el" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">NERtcVideoStreamType</a> </td><td>视频通道类型：<ul>
<li>
kNERTCVideoStreamMain：主流。</li>
<li>
kNERTCVideoStreamSub：辅流。  </li>
</ul>
</td></tr>
<tr>
<td>enabled </td><td>bool </td><td>是否开启本地视频采集与发送：<ul>
<li>
true：开启本地视频采集。</li>
<li>
false：关闭本地视频采集，此时不需要本地有摄像头。关闭后，远端用户无法接收到本地用户的视频流；但本地用户仍然可以接收到远端用户的视频流。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//打开视频主流</span></div>
<div class="line"><a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">nertc::NERtcVideoStreamType</a> type = <a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a15fcc7ab62484b7ed86661f6e7188a09">nertc::NERtcVideoStreamType::kNERTCVideoStreamMain</a>;</div>
<div class="line"><span class="keywordtype">bool</span> enable = <span class="keyword">true</span>;</div>
<div class="line">rtc_engine_-&gt;enableLocalVideo(type, enable);</div>
<div class="line"><span class="comment">//关闭视频主流</span></div>
<div class="line"><a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">nertc::NERtcVideoStreamType</a> type = <a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a15fcc7ab62484b7ed86661f6e7188a09">nertc::NERtcVideoStreamType::kNERTCVideoStreamMain</a>;</div>
<div class="line"><span class="keywordtype">bool</span> enable = <span class="keyword">false</span>;</div>
<div class="line">rtc_engine_-&gt;enableLocalVideo(type, enable);</div>
<div class="line"><span class="comment">//打开视频辅流</span></div>
<div class="line"><a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">nertc::NERtcVideoStreamType</a> type = <a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a101f9d507d87b67bc5f6da90f336f3fb">nertc::NERtcVideoStreamType::kNERTCVideoStreamSub</a>;</div>
<div class="line"><span class="keywordtype">bool</span> enable = <span class="keyword">true</span>;</div>
<div class="line">rtc_engine_-&gt;enableLocalVideo(type, enable);</div>
<div class="line"><span class="comment">//关闭视频辅流</span></div>
<div class="line"><a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">nertc::NERtcVideoStreamType</a> type = <a class="code" href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a101f9d507d87b67bc5f6da90f336f3fb">nertc::NERtcVideoStreamType::kNERTCVideoStreamSub</a>;</div>
<div class="line"><span class="keywordtype">bool</span> enable = <span class="keyword">false</span>;</div>
<div class="line">rtc_engine_-&gt;enableLocalVideo(type, enable);</div>
<div class="ttc" id="anamespacenertc_html_a41429a38d9c4e87dad27dcebc0322264"><div class="ttname"><a href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264">nertc::NERtcVideoStreamType</a></div><div class="ttdeci">NERtcVideoStreamType</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:5497</div></div>
<div class="ttc" id="anamespacenertc_html_a41429a38d9c4e87dad27dcebc0322264a101f9d507d87b67bc5f6da90f336f3fb"><div class="ttname"><a href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a101f9d507d87b67bc5f6da90f336f3fb">nertc::kNERTCVideoStreamSub</a></div><div class="ttdeci">@ kNERTCVideoStreamSub</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:5515</div></div>
<div class="ttc" id="anamespacenertc_html_a41429a38d9c4e87dad27dcebc0322264a15fcc7ab62484b7ed86661f6e7188a09"><div class="ttname"><a href="namespacenertc.html#a41429a38d9c4e87dad27dcebc0322264a15fcc7ab62484b7ed86661f6e7188a09">nertc::kNERTCVideoStreamMain</a></div><div class="ttdeci">@ kNERTCVideoStreamMain</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:5506</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd><ul>
<li>type 为 kNERTCVideoStreamMain（主流）时：<ul>
<li>开启本地视频采集后，远端会收到 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a0b84dd2fcc3a6f5fe03f36c9cc4911ad">onUserVideoStart</a> 回调。</li>
<li>关闭本地视频采集后，远端会收到 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#ac1dfb8ff38201681140c8ff7e2323bc7">onUserVideoStop</a> 回调。</li>
</ul>
</li>
<li>streamType 为 kNERtcVideoStreamTypeSub（辅流）时：<ul>
<li>开启本地视频采集后，远端会收到 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler_ex.html#a48f88b74beb1db6d8ccbca5f079912ee">onUserSubStreamVideoStart</a> 回调。</li>
<li>关闭本地视频采集后，远端会收到 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler_ex.html#abf09442bb44e42d300bcae8a1b21aaa3">onUserSubStreamVideoStop</a> 回调。 </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30001（kNERtcErrFatal）：通用错误，一般表示引擎错误，尝试再次调用此接口即可。</li>
<li>30005（kNERtcErrInvalidState）：当前状态不支持的操作，比如已开启外部视频采集。</li>
<li>30027（kNERtcErrDeviceOccupied）: 所选设备已被占用。比如已通过主流通道开启了摄像头，无法再通过辅流通道开启摄像头。</li>
<li>50000（kNERtcRuntimeErrVDMNoAuthorize）：应用未获取到操作系统的摄像头权限。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1e816fd56f1cc6953a263f6798d0f1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e816fd56f1cc6953a263f6798d0f1d4">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcEngine::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnertc_1_1_n_e_rtc_engine_context.html">NERtcEngineContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>创建 NERtc 实例。 <br  />
通过本接口可以实现创建 NERtc 实例并初始化 NERTC SDK 服务。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机 </dt><dd>请确保在调用 <a class="el" href="group__create_n_e_rtc_engine.html#ga9477c0383866743973deeda15365a16c">createNERtcEngine()</a> 方法创建 <a class="el" href="classnertc_1_1_i_rtc_engine.html">IRtcEngine</a> 对象后，再调用其他 API 前先调用该方法创建并初始化 NERtc 实例。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>使用同一个 App Key 的 App 才能进入同一个房间进行通话或直播。</li>
<li>一个 App Key 只能用于创建一个 NERtc 实例；若您需要更换 App Key，必须先调用 <a class="el" href="classnertc_1_1_i_rtc_engine.html#ac16ff6b3517d45a9cbc1504a94770b70">release</a> 方法销毁当前实例，再调用本方法重新创建实例。</li>
<li>初始化成功后，默认处于音视频通话模式。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>context </td><td><a class="el" href="structnertc_1_1_n_e_rtc_engine_context.html">NERtcEngineContext</a>  </td><td>传入的 RTC engine context 对象。  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><a class="code" href="structnertc_1_1_n_e_rtc_engine_context.html">nertc::NERtcEngineContext</a> rtc_engine_context;</div>
<div class="line">memset(&amp;rtc_engine_context, 0, <span class="keyword">sizeof</span>(<a class="code" href="structnertc_1_1_n_e_rtc_engine_context.html">nertc::NERtcEngineContext</a>));</div>
<div class="line">rtc_engine_context.<a class="code" href="structnertc_1_1_n_e_rtc_engine_context.html#a0f41a3e48eda2ea7aabb7e5aed381710">app_key</a> = app_key.c_str();</div>
<div class="line">rtc_engine_context_.log_dir_path = log_dir_path_.c_str();</div>
<div class="line">rtc_engine_context_.log_level = rtc_parameter_.log_level;</div>
<div class="line">rtc_engine_context_.log_file_max_size_KBytes = log_file_max_size_KBytes;</div>
<div class="line">rtc_engine_context_.event_handler = <span class="keyword">this</span>;</div>
<div class="line">rtc_engine_-&gt;initialize(rtc_engine_context);</div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_engine_context_html"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_engine_context.html">nertc::NERtcEngineContext</a></div><div class="ttdef"><b>Definition:</b> nertc_engine.h:28</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_engine_context_html_a0f41a3e48eda2ea7aabb7e5aed381710"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_engine_context.html#a0f41a3e48eda2ea7aabb7e5aed381710">nertc::NERtcEngineContext::app_key</a></div><div class="ttdeci">const char * app_key</div><div class="ttdef"><b>Definition:</b> nertc_engine.h:38</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关接口</dt><dd>若您不再使用 NERtc 实例，需要调用 <a class="el" href="classnertc_1_1_i_rtc_engine.html#ac16ff6b3517d45a9cbc1504a94770b70">release</a> 方法进行销毁。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30001（kNERtcErrFatal）：通用错误，比如日志路径无法访问。</li>
<li>30003（kNERtcErrInvalidParam）：参数错误，比如 app_key 为空或 log_dir_path 为空。</li>
<li>30005（kNERtcErrInvalidState)：状态错误，比如重复初始化。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="acc3f404cee7cd1b56b5019776dbb660a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3f404cee7cd1b56b5019776dbb660a">&#9670;&nbsp;</a></span>joinChannel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcEngine::joinChannel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>channel_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a>&#160;</td>
          <td class="paramname"><em>uid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>加入音视频房间。 <br  />
通过本接口可以实现加入音视频房间，加入房间后可以与房间内的其他用户进行音视频通话。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在初始化后调用该方法。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>加入房间后，同一个房间内的用户可以互相通话，多个用户加入同一个房间，可以群聊。使用不同 App Key 的 App 之间不能互通。</li>
<li>加入音视频房间时，如果指定房间尚未创建，云信 服务器内部会自动创建一个同名房间。</li>
<li>传参中 uid 可选，若不指定则默认为 0，SDK 会自动分配一个随机 uid，并在 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a3f55353db4a1369d70ec3859e91c7337">onJoinChannel</a> 回调方法中返回；App 层必须记住该返回值并维护，SDK 不对该返回值进行维护。</li>
<li>用户成功加入房间后，默认订阅房间内所有其他用户的音频流，可能会因此产生用量并影响计费；若您想取消自动订阅，可以在通话前通过调用 <a class="el" href="classnertc_1_1_i_rtc_engine_ex.html#a4d39a81643f19979461ec0bb569f4a0d">setParameters</a> 方法实现。</li>
<li>网络测速过程中无法加入房间。</li>
<li>若使用了云代理功能，uid 不允许传 0，请用真实的 uid。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>token </td><td>const char </td><td>安全认证签名（NERTC Token），可以设置为：<ul>
<li>
null。调试模式下可设置为 null。安全性不高，建议在产品正式上线前在云信控制台中将鉴权方式恢复为默认的安全模式。</li>
<li>
已获取的 NERTC Token。安全模式下必须设置为获取到的 Token 。若未传入正确的 Token 将无法进入房间。推荐使用安全模式。  </li>
</ul>
</td></tr>
<tr>
<td>channelName </td><td>const char </td><td>房间名称，设置相同房间名称的用户会进入同一个通话房间。<ul>
<li>
字符串格式，长度为 1 ~ 64 字节。</li>
<li>
支持以下 89 个字符：a-z, A-Z, 0-9, space, !#$%&amp;()+-:;≤.,&gt;? @[]^_{|}~”  </li>
</ul>
</td></tr>
<tr>
<td>uid </td><td>uid_t </td><td>用户的唯一标识 ID。  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line">rtc_engine_-&gt;joinChannel(token, <span class="stringliteral">&quot;124514&quot;</span>, 1);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关接口</dt><dd><ul>
<li>您可以调用 <a class="el" href="classnertc_1_1_i_rtc_engine.html#a6fbc54a71986a4a4a1c9c24d2c29e884">leaveChannel</a> 方法离开房间。</li>
<li>直播场景中，观众角色可以通过 <a class="el" href="classnertc_1_1_i_rtc_engine.html#a827ecfee86c395f564a18012fa919b59">switchChannel</a> 接口切换房间。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>相关回调</dt><dd><ul>
<li>成功调用该方法加入房间后，本地会触发 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a3f55353db4a1369d70ec3859e91c7337">onJoinChannel</a> 回调，远端会触发 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a84a5b3eb47d7f0465082db4bd4bd4989">onUserJoined</a> 回调。</li>
<li>在弱网环境下，若客户端和服务器失去连接，SDK 会自动重连，并在自动重连成功后触发 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a8a9d5275c71e950c35604b851c9a0db6">onRejoinChannel</a> 回调。 </li>
</ul>
</dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30001（kNERtcErrFatal）：重复入会或获取房间信息失败。</li>
<li>30005（kNERtcErrInvalidState)：状态错误，比如引擎尚未初始化或正在进行网络探测。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a29bdc1e3e13990b94ab9e92c8c7b5693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29bdc1e3e13990b94ab9e92c8c7b5693">&#9670;&nbsp;</a></span>joinChannel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcEngine::joinChannel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>channel_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a>&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnertc_1_1_n_e_rtc_join_channel_options.html">NERtcJoinChannelOptions</a>&#160;</td>
          <td class="paramname"><em>channel_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>加入音视频房间。 <br  />
通过本接口可以实现加入音视频房间，加入房间后可以与房间内的其他用户进行音视频通话。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在初始化后调用该方法。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>加入房间后，同一个房间内的用户可以互相通话，多个用户加入同一个房间，可以群聊。使用不同 App Key 的 App 之间不能互通。</li>
<li>加入音视频房间时，如果指定房间尚未创建，云信 服务器内部会自动创建一个同名房间。</li>
<li>传参中 uid 可选，若不指定则默认为 0，SDK 会自动分配一个随机 uid，并在 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a3f55353db4a1369d70ec3859e91c7337">onJoinChannel</a> 回调方法中返回；App 层必须记住该返回值并维护，SDK 不对该返回值进行维护。</li>
<li>用户成功加入房间后，默认订阅房间内所有其他用户的音频流，可能会因此产生用量并影响计费；若您想取消自动订阅，可以在通话前通过调用 <a class="el" href="classnertc_1_1_i_rtc_engine_ex.html#a4d39a81643f19979461ec0bb569f4a0d">setParameters</a> 方法实现。</li>
<li>网络测速过程中无法加入房间。</li>
<li>若使用了云代理功能，uid 不允许传 0，请用真实的 uid。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>token </td><td>const char </td><td>安全认证签名（NERTC Token），可以设置为：<ul>
<li>
null。调试模式下可设置为 null。安全性不高，建议在产品正式上线前在云信控制台中将鉴权方式恢复为默认的安全模式。</li>
<li>
已获取的 NERTC Token。安全模式下必须设置为获取到的 Token 。若未传入正确的 Token 将无法进入房间。推荐使用安全模式。  </li>
</ul>
</td></tr>
<tr>
<td>channelName </td><td>const char </td><td>房间名称，设置相同房间名称的用户会进入同一个通话房间。<ul>
<li>
字符串格式，长度为 1 ~ 64 字节。</li>
<li>
支持以下 89 个字符：a-z, A-Z, 0-9, space, !#$%&amp;()+-:;≤.,&gt;? @[]^_{|}~”  </li>
</ul>
</td></tr>
<tr>
<td>uid </td><td>uid_t </td><td>用户的唯一标识 ID。  </td></tr>
<tr>
<td>channel_options </td><td><a class="el" href="structnertc_1_1_n_e_rtc_join_channel_options.html">NERtcJoinChannelOptions</a> </td><td>加入房间时设置一些特定的房间参数。默认值为 nil。  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line">rtc_engine_-&gt;joinChannel(token, <span class="stringliteral">&quot;124514&quot;</span>, 1);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关接口</dt><dd><ul>
<li>您可以调用 <a class="el" href="classnertc_1_1_i_rtc_engine.html#a6fbc54a71986a4a4a1c9c24d2c29e884">leaveChannel</a> 方法离开房间。</li>
<li>直播场景中，观众角色可以通过 <a class="el" href="classnertc_1_1_i_rtc_engine.html#a827ecfee86c395f564a18012fa919b59">switchChannel</a> 接口切换房间。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>相关回调</dt><dd><ul>
<li>成功调用该方法加入房间后，本地会触发 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a3f55353db4a1369d70ec3859e91c7337">onJoinChannel</a> 回调，远端会触发 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a84a5b3eb47d7f0465082db4bd4bd4989">onUserJoined</a> 回调。</li>
<li>在弱网环境下，若客户端和服务器失去连接，SDK 会自动重连，并在自动重连成功后触发 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a8a9d5275c71e950c35604b851c9a0db6">onRejoinChannel</a> 回调。 </li>
</ul>
</dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30001（kNERtcErrFatal）：重复入会或获取房间信息失败。</li>
<li>30005（kNERtcErrInvalidState)：状态错误，比如引擎尚未初始化或正在进行网络探测。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6fbc54a71986a4a4a1c9c24d2c29e884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbc54a71986a4a4a1c9c24d2c29e884">&#9670;&nbsp;</a></span>leaveChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcEngine::leaveChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>离开音视频房间。 <br  />
通过本接口可以实现挂断或退出通话，并释放本房间内的相关资源。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在初始化并成功加入房间后调用该方法。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>结束通话时必须调用此方法离开房间，否则无法开始下一次通话。</li>
<li>该方法是异步操作，调用返回时并没有真正退出频道。在真正退出房间后，SDK 会触发 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#ac1f8466195da1eb0cc2be9916d9912be">onLeaveChannel</a> 回调。</li>
<li>如果在调用 leaveChannel 后立即调用 <a class="el" href="classnertc_1_1_i_rtc_engine.html#ac16ff6b3517d45a9cbc1504a94770b70">release</a> 方法，可能会无法正常离开房间；建议您在收到 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#ac1f8466195da1eb0cc2be9916d9912be">onLeaveChannel</a> 回调之后再调用 <a class="el" href="classnertc_1_1_i_rtc_engine.html#ac16ff6b3517d45a9cbc1504a94770b70">release</a> 方法释放会话相关所有资源。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line">rtc_engine_-&gt;leaveChannel();</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd>成功调用该方法离开房间后，本地会触发 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#ac1f8466195da1eb0cc2be9916d9912be">onLeaveChannel</a> 回调，远端会触发 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a573c5039eeba1acab4fe0bd28ec6e19c">onUserLeft</a> 回调。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30001（kNERtcErrFatal）：正在进行网络探测。</li>
<li>30005（kNERtcErrInvalidState)：状态错误，比如引擎尚未初始化。</li>
<li>30101（kNERtcErrChannelNotJoined）：尚未加入房间。</li>
<li>30102（kNERtcErrChannelRepleatedlyLeave）：重复离开房间。</li>
<li>30104（kNERtcErrSessionNotFound）：会话未找到。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2f0e1e225e0fe8fc7ad1e9138d62caea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0e1e225e0fe8fc7ad1e9138d62caea">&#9670;&nbsp;</a></span>queryInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcEngine::queryInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a13dd8adcb4f73bd24e37726272084a7d">NERtcInterfaceIdType</a>&#160;</td>
          <td class="paramname"><em>iid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>inter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>获取设备管理员对象的指针。 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iid</td><td>想要获取的接口的iid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inter</td><td>指向 DeviceManager 对象的指针。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0: 方法调用成功；</li>
<li>其他: 方法调用失败。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac16ff6b3517d45a9cbc1504a94770b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16ff6b3517d45a9cbc1504a94770b70">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nertc::IRtcEngine::release </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>销毁 NERtc 实例，并释放资源。 <br  />
该方法释放 NERTC SDK 使用的所有资源。有些 App 只在用户需要时才进行实时音视频通信，完成音视频通话后，则将资源释放出来用于其他操作，该方法适用于此类情况。</p><ul>
<li>该接口需要在调用 <a class="el" href="classnertc_1_1_i_rtc_engine.html#a6fbc54a71986a4a4a1c9c24d2c29e884">leaveChannel</a> 方法并收到本端离开房间的回调后调用。或收到 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#afa9019aa0b86c9d056814d0921069c8f">onDisconnect</a> 回调、重连失败时调用此方法销毁实例，并释放资源。</li>
<li>调用该释放实例后，您将无法再使用 SDK 的其它方法和回调。如需再次使用实时音视频通话功能，您必须重新创建一个新的 NERtc 实例。 <dl class="section note"><dt>注解</dt><dd></dd></dl>
</li>
<li>该方法为同步调用，需要等待 NERtcEngine 实例资源释放后才能执行其他操作，建议在子线程中调用该方法，避免主线程阻塞。此外，请勿在 SDK 的回调中调用该方法，否则由于 SDK 要等待回调返回才能回收相关的对象资源，会造成死锁。SDK 会自动检测这种死锁并转为异步调用，但是检测本身会消耗额外的时间。</li>
<li>如果需要重新使用 IRtcEngine，调用该方法后需要调用 <a class="el" href="group__create_n_e_rtc_engine.html#ga85f37bd2b9f86d5aa94943981892329a">destroyNERtcEngine</a> 方法销毁引擎，等待执行结束后才能再次调用 <a class="el" href="group__create_n_e_rtc_engine.html#ga9477c0383866743973deeda15365a16c">createNERtcEngine</a>。 <dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>默认为 true 且只能设置为 true，表示同步调用，等待 <a class="el" href="classnertc_1_1_i_rtc_engine.html">IRtcEngine</a> 对象资源释放后再返回。 </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a6195db00acf739ca2cb183015abffd5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6195db00acf739ca2cb183015abffd5b">&#9670;&nbsp;</a></span>setChannelProfile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcEngine::setChannelProfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#ac30f4b7ce13da5d664df0d2a6986e940">NERtcChannelProfileType</a>&#160;</td>
          <td class="paramname"><em>profile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置房间场景。 <br  />
 通过此接口可以实现设置房间场景为通话（默认）或直播场景。针对不同场景采取的优化策略不同，如通话场景侧重语音流畅度，直播场景侧重视频清晰度。 </p><dl class="section since"><dt>自从</dt><dd>V3.6.0 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在初始化后调用该方法，且该方法仅可在加入房间前调用。 </dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>profile </td><td><a class="el" href="namespacenertc.html#ac30f4b7ce13da5d664df0d2a6986e940">NERtcChannelProfileType</a> </td><td>设置房间场景：<ul>
<li>
kNERtcChannelProfileCommunication（0）：通话场景。</li>
<li>
kNERtcChannelProfileLiveBroadcasting（1）：直播场景。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//设置房间场景为直播场景</span></div>
<div class="line">rtc_engine-&gt;setChannelProfile(<a class="code" href="namespacenertc.html#ac30f4b7ce13da5d664df0d2a6986e940af4095c14e4ce127e60649d49004136d7">nertc::kNERtcChannelProfileLiveBroadcasting</a>);</div>
<div class="ttc" id="anamespacenertc_html_ac30f4b7ce13da5d664df0d2a6986e940af4095c14e4ce127e60649d49004136d7"><div class="ttname"><a href="namespacenertc.html#ac30f4b7ce13da5d664df0d2a6986e940af4095c14e4ce127e60649d49004136d7">nertc::kNERtcChannelProfileLiveBroadcasting</a></div><div class="ttdeci">@ kNERtcChannelProfileLiveBroadcasting</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:295</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30003（kNERtcErrInvalidParam）：参数错误。</li>
<li>30004（kNERtcErrNotSupported）：不支持的操作，比如不是对主房间的设置。</li>
<li>30005（kNERtcErrInvalidState)：当前状态不支持的操作，比如引擎尚未初始化。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae58ed7e0e0e4383939fc16a6a77d2570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58ed7e0e0e4383939fc16a6a77d2570">&#9670;&nbsp;</a></span>setClientRole()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcEngine::setClientRole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a1277b5498334b7efe3ad260d72350128">NERtcClientRole</a>&#160;</td>
          <td class="paramname"><em>role</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置直播场景下的用户角色。 <br  />
通过本接口可以实现将用户角色在“主播”（kNERtcClientRoleBroadcaster）和“观众“（kNERtcClientRoleAudience）之间的切换，用户加入房间后默认为“主播”。 </p><dl class="section since"><dt>自从</dt><dd>V3.9.0 </dd></dl>
<dl class="section user"><dt>使用前提</dt><dd>该方法仅在通过 <a class="el" href="classnertc_1_1_i_rtc_engine.html#a6195db00acf739ca2cb183015abffd5b">setChannelProfile</a> 方法设置房间场景为直播场景（kNERtcChannelProfileLiveBroadcasting）时调用有效。 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在初始化后调用该方法，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section user"><dt>业务场景</dt><dd>适用于观众上下麦与主播互动的互动直播场景。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>用户切换为观众角色时，SDK 会自动关闭音视频设备。 </dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>role </td><td><a class="el" href="namespacenertc.html#a1277b5498334b7efe3ad260d72350128">NERtcClientRole</a>  </td><td>用户角色：<ul>
<li>
kNERtcClientRoleBroadcaster（0）：设置用户角色为主播。主播可以开关摄像头等设备、可以发布流、可以操作互动直播推流相关接口、加入或退出房间状态对其他房间内用户可见。</li>
<li>
kNERtcClientRoleAudience（1）：设置用户角色为观众。观众只能收流不能发流加入或退出房间状态对其他房间内用户不可见。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//切换用户角色为主播</span></div>
<div class="line">rtc_engine_-&gt;setClientRole(<a class="code" href="namespacenertc.html#a1277b5498334b7efe3ad260d72350128ac92856d4ac2f538c1ad8bac9c6f578d7">nertc::kNERtcClientRoleBroadcaster</a>);</div>
<div class="line"><span class="comment">//切换用户角色为观众</span></div>
<div class="line">rtc_engine_-&gt;setClientRole(<a class="code" href="namespacenertc.html#a1277b5498334b7efe3ad260d72350128ac5a941fda770423acd9f7471071e7aef">nertc::kNERtcClientRoleAudience</a>);</div>
<div class="ttc" id="anamespacenertc_html_a1277b5498334b7efe3ad260d72350128ac5a941fda770423acd9f7471071e7aef"><div class="ttname"><a href="namespacenertc.html#a1277b5498334b7efe3ad260d72350128ac5a941fda770423acd9f7471071e7aef">nertc::kNERtcClientRoleAudience</a></div><div class="ttdeci">@ kNERtcClientRoleAudience</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:266</div></div>
<div class="ttc" id="anamespacenertc_html_a1277b5498334b7efe3ad260d72350128ac92856d4ac2f538c1ad8bac9c6f578d7"><div class="ttname"><a href="namespacenertc.html#a1277b5498334b7efe3ad260d72350128ac92856d4ac2f538c1ad8bac9c6f578d7">nertc::kNERtcClientRoleBroadcaster</a></div><div class="ttdeci">@ kNERtcClientRoleBroadcaster</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:255</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd><ul>
<li>加入房间前调用该方法设置用户角色，不会触发任何回调，在加入房间成功后角色自动生效：<ul>
<li>设置用户角色为主播：加入房间后，远端用户触发 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a84a5b3eb47d7f0465082db4bd4bd4989">onUserJoined</a> 回调。</li>
<li>设置用户角色为观众：加入房间后，远端用户不触发任何回调。</li>
</ul>
</li>
<li>加入房间后调用该方法切换用户角色：<ul>
<li>从观众角色切为主播：本端用户触发 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a6cebf3cc8ba85e96e43eec3953f17b0e">onClientRoleChanged</a> 回调，远端用户触发 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a4dd427d417892f99812ac42ac5db22ac">onUserJoined</a> 回调。</li>
<li>从主播角色切为观众：本端用户触发 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a6cebf3cc8ba85e96e43eec3953f17b0e">onClientRoleChanged</a> 回调，远端用户触发 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a05306dbb0e602ea608515b5e394202cf">onUserleft</a> 回调。 </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30001（kNERtcErrFatal)：引擎未创建成功。</li>
<li>30005（kNERtcErrInvalidState)：当前状态不支持的操作，不支持切换角色（主播/观众）。</li>
<li>30101（kNERtcErrChannelNotJoined): 尚未加入房间。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad7306ae7edc1cadedceb6c2cde8df279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7306ae7edc1cadedceb6c2cde8df279">&#9670;&nbsp;</a></span>setupLocalVideoCanvas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcEngine::setupLocalVideoCanvas </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnertc_1_1_n_e_rtc_video_canvas.html">NERtcVideoCanvas</a> *&#160;</td>
          <td class="paramname"><em>canvas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置本地用户视图。 <br  />
 通过本接口可以实现绑定本地用户和显示视图，并设置本地用户视图在本地显示时的镜像模式和裁减比例，只影响本地用户看到的视频画面。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机 </dt><dd>请在初始化后调用该方法，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>纯音频 SDK 禁用该接口，如需使用请前往<a href="https://doc.yunxin.163.com/nertc/sdk-download" target="_blank">云信官网</a>下载并替换成视频 SDK。</li>
<li>在实际业务中，通常建议在初始化后即调用该方法进行本地视图设置，然后再加入房间或开启预览；若您开发的是 macOS 平台的 App，若使用的是外部渲染，必须在初始化 SDK 时设置本地视图。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>canvas </td><td><a class="el" href="structnertc_1_1_n_e_rtc_video_canvas.html">NERtcVideoCanvas</a>  </td><td>本地用户视频的画布。设置为 NULL 表示取消并释放已设置的画布，详细信息请参考 <a class="el" href="structnertc_1_1_n_e_rtc_video_canvas.html">NERtcVideoCanvas</a>。  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html">nertc::NERtcVideoCanvas</a> canvas;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#a33c22abb5bb5dd9f94fb587367284026">cb</a> = <span class="keyword">nullptr</span>;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#a0a5afd8e0817806f1afc1da29b39e461">user_data</a> = <span class="keyword">nullptr</span>;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#ab75d8766a11caf1be65102a7639a5c2c">window</a> = window;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#ad9063ff3bf1a7443c7f90761f3b43e19">scaling_mode</a> = <a class="code" href="namespacenertc.html#a410a5b7182fad6ff52def434a58de4e5a7189e90604dcb50626d15981b89c2409">nertc::kNERtcVideoScaleFit</a>;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#ab2c3f29cccd971d63c055a8df3320053">mirror_mode</a> = <a class="code" href="namespacenertc.html#aa3abbd3e5bbe492f54f9720d0b25d3f8a35100cf833e23603ab1a6170bf1c1683">nertc::kNERtcVideoMirrorModeAuto</a>;</div>
<div class="line">rtc_engine_-&gt;setupLocalVideoCanvas(canvas)</div>
<div class="ttc" id="anamespacenertc_html_a410a5b7182fad6ff52def434a58de4e5a7189e90604dcb50626d15981b89c2409"><div class="ttname"><a href="namespacenertc.html#a410a5b7182fad6ff52def434a58de4e5a7189e90604dcb50626d15981b89c2409">nertc::kNERtcVideoScaleFit</a></div><div class="ttdeci">@ kNERtcVideoScaleFit</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:2085</div></div>
<div class="ttc" id="anamespacenertc_html_aa3abbd3e5bbe492f54f9720d0b25d3f8a35100cf833e23603ab1a6170bf1c1683"><div class="ttname"><a href="namespacenertc.html#aa3abbd3e5bbe492f54f9720d0b25d3f8a35100cf833e23603ab1a6170bf1c1683">nertc::kNERtcVideoMirrorModeAuto</a></div><div class="ttdeci">@ kNERtcVideoMirrorModeAuto</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:2122</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_canvas_html"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_canvas.html">nertc::NERtcVideoCanvas</a></div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:4235</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_canvas_html_a0a5afd8e0817806f1afc1da29b39e461"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_canvas.html#a0a5afd8e0817806f1afc1da29b39e461">nertc::NERtcVideoCanvas::user_data</a></div><div class="ttdeci">void * user_data</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:4257</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_canvas_html_a33c22abb5bb5dd9f94fb587367284026"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_canvas.html#a33c22abb5bb5dd9f94fb587367284026">nertc::NERtcVideoCanvas::cb</a></div><div class="ttdeci">onFrameDataCallback cb</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:4246</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_canvas_html_ab2c3f29cccd971d63c055a8df3320053"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_canvas.html#ab2c3f29cccd971d63c055a8df3320053">nertc::NERtcVideoCanvas::mirror_mode</a></div><div class="ttdeci">NERtcVideoMirrorMode mirror_mode</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:4292</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_canvas_html_ab75d8766a11caf1be65102a7639a5c2c"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_canvas.html#ab75d8766a11caf1be65102a7639a5c2c">nertc::NERtcVideoCanvas::window</a></div><div class="ttdeci">void * window</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:4269</div></div>
<div class="ttc" id="astructnertc_1_1_n_e_rtc_video_canvas_html_ad9063ff3bf1a7443c7f90761f3b43e19"><div class="ttname"><a href="structnertc_1_1_n_e_rtc_video_canvas.html#ad9063ff3bf1a7443c7f90761f3b43e19">nertc::NERtcVideoCanvas::scaling_mode</a></div><div class="ttdeci">NERtcVideoScalingMode scaling_mode</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:4278</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关接口</dt><dd>若您希望在通话中更新本地用户视图的渲染或镜像模式，请使用 <a class="el" href="classnertc_1_1_i_rtc_engine_ex.html#aa0e5456afae0c8b1f553de8884dabb5d">setLocalRenderMode</a> 方法。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30001（kNERtcErrFatal）：画布创建失败。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a16192ada0272bb48adc18848e68dc57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16192ada0272bb48adc18848e68dc57d">&#9670;&nbsp;</a></span>setupRemoteVideoCanvas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcEngine::setupRemoteVideoCanvas </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a>&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnertc_1_1_n_e_rtc_video_canvas.html">NERtcVideoCanvas</a> *&#160;</td>
          <td class="paramname"><em>canvas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置远端用户视图。 <br  />
通过本接口可以实现绑定远端用户和显示视图，并设置远端用户视图在本地显示时的镜像模式和裁减比例，只影响本地用户看到的视频画面。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机 </dt><dd>请在初始化后调用该方法，且该方法在加入房间前后均可调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>您可以通过设置 canvas 参数为空以解除远端用户视图绑定；退出房间后，SDK 也会主动清除远端用户和视图的绑定关系。 </dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>canvas </td><td><a class="el" href="structnertc_1_1_n_e_rtc_video_canvas.html">NERtcVideoCanvas</a>  </td><td>远端用户视频的画布。  </td></tr>
<tr>
<td>uid </td><td>uid_t </td><td>远端用户的 ID。可以在 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a84a5b3eb47d7f0465082db4bd4bd4989">onUserJoined</a> 回调中获取。  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html">nertc::NERtcVideoCanvas</a> canvas;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#a33c22abb5bb5dd9f94fb587367284026">cb</a> = <span class="keyword">nullptr</span>;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#a0a5afd8e0817806f1afc1da29b39e461">user_data</a> = <span class="keyword">nullptr</span>;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#ab75d8766a11caf1be65102a7639a5c2c">window</a> = window;</div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#ad9063ff3bf1a7443c7f90761f3b43e19">scaling_mode</a> = <a class="code" href="namespacenertc.html#a410a5b7182fad6ff52def434a58de4e5a7189e90604dcb50626d15981b89c2409">nertc::kNERtcVideoScaleFit</a>; </div>
<div class="line">canvas.<a class="code" href="structnertc_1_1_n_e_rtc_video_canvas.html#ab2c3f29cccd971d63c055a8df3320053">mirror_mode</a>  = <a class="code" href="namespacenertc.html#aa3abbd3e5bbe492f54f9720d0b25d3f8a35100cf833e23603ab1a6170bf1c1683">nertc::kNERtcVideoMirrorModeAuto</a>;</div>
<div class="line">rtc_engine_-&gt;setupRemoteVideoCanvas(uid, canvas);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关接口</dt><dd>若您希望在通话中更新远端用户视图的渲染模式，请调用 <a class="el" href="classnertc_1_1_i_rtc_engine_ex.html#aaeaa9996cdc8b2a47022030e4eaa9712">setRemoteRenderMode</a> 方法。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30001（kNERtcErrFatal）：画布创建失败。</li>
<li>30005（kNERtcErrInvalidState）：当前状态不支持的操作，比如引擎尚未初始化。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a385748f3ea0003ec0eb49f925774ddac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385748f3ea0003ec0eb49f925774ddac">&#9670;&nbsp;</a></span>subscribeRemoteVideoStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcEngine::subscribeRemoteVideoStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#a6af385d971f538ddd7b5ee227ca4a451">uid_t</a>&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenertc.html#af9a1648ac76c0c9682bdadeca2f5c80d">NERtcRemoteVideoStreamType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subscribe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>订阅或取消订阅指定远端用户的视频主流。 <br  />
加入房间后，默认不订阅所有远端用户的视频主流；若您希望看到指定远端用户的视频，可以在监听到对方加入房间或发布视频流之后，通过此方法订阅该用户的视频主流。 </p><dl class="section since"><dt>自从</dt><dd>V3.5.0 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在初始化后调用该方法，且该方法仅可在加入房间后调用。 </dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>uid </td><td>uid_t </td><td>指定用户的 ID。  </td></tr>
<tr>
<td>streamType </td><td><a class="el" href="namespacenertc.html#af9a1648ac76c0c9682bdadeca2f5c80d">NERtcRemoteVideoStreamType</a> </td><td>订阅的视频流类型：<ul>
<li>
kNERtcRemoteVideoStreamTypeHigh：高清画质的大流。</li>
<li>
kNERtcRemoteVideoStreamTypeLow：低清画质的小流。</li>
<li>
kNERtcRemoteVideoStreamTypeNone：不订阅。  </li>
</ul>
</td></tr>
<tr>
<td>subscribe </td><td>bool </td><td>是否订阅远端用户的视频流：<ul>
<li>
true：订阅指定视频流。</li>
<li>
false：不订阅指定视频流。  </li>
</ul>
</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="comment">//订阅对方uid为12345的大流</span></div>
<div class="line">rtc_engine_-&gt;subscribeRemoteVideoStream(12345, <a class="code" href="namespacenertc.html#af9a1648ac76c0c9682bdadeca2f5c80da90daeee06a77341e057f4d698820f8c7">nertc::kNERtcRemoteVideoStreamTypeHigh</a>,<span class="keyword">true</span>);</div>
<div class="ttc" id="anamespacenertc_html_af9a1648ac76c0c9682bdadeca2f5c80da90daeee06a77341e057f4d698820f8c7"><div class="ttname"><a href="namespacenertc.html#af9a1648ac76c0c9682bdadeca2f5c80da90daeee06a77341e057f4d698820f8c7">nertc::kNERtcRemoteVideoStreamTypeHigh</a></div><div class="ttdeci">@ kNERtcRemoteVideoStreamTypeHigh</div><div class="ttdef"><b>Definition:</b> nertc_engine_defines.h:1707</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关接口</dt><dd>若您希望订阅指定远端用户的视频辅流，请调用 <a class="el" href="classnertc_1_1_i_rtc_engine_ex.html#a210b788405ba94697dfefdd501bac078">subscribeRemoteVideoSubStream</a>} 方法。 </dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）：方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>30001（kNERtcErrFatal）：画布为空对象，创建远端 peerconnection 失败。</li>
<li>30005（kNERtcErrInvalidState)：状态错误，比如引擎尚未初始化。</li>
<li>30009（kNERtcErrInvalidDeviceSourceID）：设备 ID 非法。</li>
<li>30105（kNERtcErrUserNotFound）：未找到指定用户。</li>
<li>30106（kNERtcErrInvalidUserID）：非法指定用户，比如订阅了本端。</li>
<li>30107（kNERtcErrMediaNotStarted）：媒体会话未建立，比如对端未开启视频主流。</li>
<li>30108（kNERtcErrSourceNotFound）：媒体源未找到，比如对端未开启视频主流。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a827ecfee86c395f564a18012fa919b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827ecfee86c395f564a18012fa919b59">&#9670;&nbsp;</a></span>switchChannel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcEngine::switchChannel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>channel_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>快速切换音视频房间。 通过此接口可以实现当房间场景为直播场景时，从当前房间快速切换至另一个房间。 </p><dl class="section user"><dt>使用前提</dt><dd>请先通过 <a class="el" href="classnertc_1_1_i_rtc_engine.html#a6195db00acf739ca2cb183015abffd5b">setChannelProfile</a> 接口设置房间模式为直播模式。 </dd></dl>
<dl class="section user"><dt>调用时机</dt><dd>请在引擎初始化之后调用此接口，且该方法仅可在加入房间后调用。 </dd></dl>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>房间成员成功切换房间后，将会保持切换前的音视频的状态。</li>
<li>v5.5.10 及之后版本，主播和观众都支持调用本接口快速切换至另一个房间。</li>
<li>v5.5.10 之前版本，只支持观众调用本接口快速切换至另一个房间。 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>参数说明</dt><dd><table class="doxtable">
<tr>
<th><b>参数名称</b> </th><th><b>类型</b> </th><th><b>描述</b>  </th></tr>
<tr>
<td>token </td><td>const char* </td><td>在服务器端生成的用于鉴权的安全认证签名（Token），可设置为：<ul>
<li>
已获取的 NERTC Token。安全模式下必须设置为获取到的 Token，默认 Token 有效期为 10min，也可以定期通过应用服务器向云信服务器申请 Token 或者申请长期且可复用的 Token。</li>
<li>
null。调试模式下可设置为 null。安全性不高，建议在产品正式上线前在云信控制台中将鉴权方式恢复为默认的安全模式。  </li>
</ul>
</td></tr>
<tr>
<td>channel_name </td><td>const char* </td><td>期望切换到的目标房间名称。  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>示例代码</dt><dd><div class="fragment"><div class="line"><span class="keywordflow">if</span> (rtc_engine_) {</div>
<div class="line">    ret = rtc_engine_-&gt;switchChannel(token_.c_str(), room_name.c_str());</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>相关回调</dt><dd>成功调用此接口切换房间后：<ul>
<li>本端用户会先收到 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#ac1f8466195da1eb0cc2be9916d9912be">onLeaveChannel</a> 回调，其中 result 参数为 kNERtcErrChannelLeaveBySwitchAction，再收到成功加入新房间的回调 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a3f55353db4a1369d70ec3859e91c7337">onJoinChannel</a>。</li>
<li>远端用户会收到 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a05306dbb0e602ea608515b5e394202cf">onUserLeft</a> 和 <a class="el" href="classnertc_1_1_i_rtc_engine_event_handler.html#a4dd427d417892f99812ac42ac5db22ac">onUserJoined</a> 的回调。 </li>
</ul>
</dd></dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0（kNERtcNoError）： 方法调用成功。</li>
<li>其他：方法调用失败。<ul>
<li>403（kNERtcErrChannelReservePermissionDenied）：没有权限，比如主播无法切换房间。</li>
<li>30001（kNERtcErrFatal）：通用错误。</li>
<li>30003（kNERtcErrInvalidParam）：参数错误，比如房间名称为空字符串。</li>
<li>30100（kNERtcErrChannelAlreadyJoined）：重复加入房间。</li>
<li>30109（kNERtcErrSwitchChannelInvalidState）：尚未加入房间。 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae71d007ffe2d13a96dedcd68d7f06806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71d007ffe2d13a96dedcd68d7f06806">&#9670;&nbsp;</a></span>switchChannel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcEngine::switchChannel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>channel_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnertc_1_1_n_e_rtc_join_channel_options.html">NERtcJoinChannelOptions</a>&#160;</td>
          <td class="paramname"><em>channel_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>快速切换音视频房间。 <br  />
房间场景为直播场景时，可以调用该方法从当前房间快速切换至另一个房间。 <br  />
成功调用该方切换房间后，本端会先收到离开房间的回调 onLeaveChannel，再收到成功加入新房间的回调 onJoinChannel。远端用户会收到 onUserLeave 和 onUserJoined 的回调。 </p><dl class="section note"><dt>注解</dt><dd><ul>
<li>房间成员成功切换房间后，默认订阅房间内所有其他成员的音频流，因此产生用量并影响计费。如果想取消订阅，可以通过调用相应的 subscribeRemoteAudio 方法传入 false 实现。 </li>
</ul>
</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">token</td><td>安全认证签名（NERTC Token）。可设置为：<ul>
<li>null。调试模式下可设置为 null。建议在产品正式上线前在云信控制台中将鉴权方式恢复为默认的安全模式。</li>
<li>已获取的NERTC Token。安全模式下必须设置为获取到的 Token 。若未传入正确的 Token 将无法进入房间。推荐使用安全模式。 </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_name</td><td>期望切换到的目标房间名称。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_options</td><td>加入房间时设置一些特定的房间参数，详情参考<a class="el" href="structnertc_1_1_n_e_rtc_join_channel_options.html">NERtcJoinChannelOptions</a>。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0(<a class="el" href="namespacenertc.html#af062cfe332d58922ac8c020d55f9bb17a4557f34a02a4664f885d3bc329114b1b">kNERtcNoError</a>)：方法调用成功。</li>
<li>30001(<a class="el" href="namespacenertc.html#af062cfe332d58922ac8c020d55f9bb17ab0d4df087aca771f4fb9beae010d29a2">kNERtcErrFatal</a>)：通用错误。</li>
<li>30003(<a class="el" href="namespacenertc.html#af062cfe332d58922ac8c020d55f9bb17a59c84121b01e3bfb7997e8151651d8f3">kNERtcErrInvalidParam</a>)：参数错误。</li>
<li>30109(<a class="el" href="namespacenertc.html#af062cfe332d58922ac8c020d55f9bb17a01663267db14556ea392e0b31cf512b6">kNERtcErrSwitchChannelInvalidState</a>): 切换房间状态无效。</li>
<li>403(<a class="el" href="namespacenertc.html#af062cfe332d58922ac8c020d55f9bb17a8e357b832e04b84d230bfb43558f28d6">kNERtcErrChannelReservePermissionDenied</a>): 用户角色不是观众。</li>
<li>30100(<a class="el" href="namespacenertc.html#af062cfe332d58922ac8c020d55f9bb17ae0420e5316b4b57b5627cb0d259d6963">kNERtcErrChannelAlreadyJoined</a>): 房间名无效，已在此房间中。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a691e74abef7cf3c41a3c8ccf8691fd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691e74abef7cf3c41a3c8ccf8691fd40">&#9670;&nbsp;</a></span>switchChannelEx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int nertc::IRtcEngine::switchChannelEx </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>channel_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnertc_1_1_n_e_rtc_join_channel_options_ex.html">NERtcJoinChannelOptionsEx</a>&#160;</td>
          <td class="paramname"><em>channel_options_ex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>快速切换音视频房间。 <br  />
房间场景为直播场景时，房间中角色为观众的成员可以调用该方法从当前房间快速切换至另一个房间。 <br  />
成功调用该方切换房间后，本端会先收到离开房间的回调 onLeaveChannel，再收到成功加入新房间的回调 onJoinChannel。远端用户会收到 onUserLeave 和 onUserJoined 的回调。 </p><dl class="section note"><dt>注解</dt><dd><ul>
<li>该方法仅适用于直播场景中，角色为观众的音视频房间成员。即已通过接口 setchannelprofile 设置房间场景为直播，通过 setClientRole 设置房间成员的角色为观众。</li>
</ul>
</dd></dl>
<ul>
<li>房间成员成功切换房间后，默认订阅房间内所有其他成员的音频流，因此产生用量并影响计费。如果想取消订阅，可以通过调用相应的 subscribeRemoteAudio 方法传入 false 实现。 <dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">token</td><td>安全认证签名（NERTC Token）。可设置为：<ul>
<li>null。调试模式下可设置为 null。建议在产品正式上线前在云信控制台中将鉴权方式恢复为默认的安全模式。</li>
<li>已获取的NERTC Token。安全模式下必须设置为获取到的 Token 。若未传入正确的 Token 将无法进入房间。推荐使用安全模式。 </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_name</td><td>期望切换到的目标房间名称。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_options</td><td>加入房间时设置一些特定的房间参数，详情参考<a class="el" href="structnertc_1_1_n_e_rtc_join_channel_options.html">NERtcJoinChannelOptions</a>。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><ul>
<li>0(<a class="el" href="namespacenertc.html#af062cfe332d58922ac8c020d55f9bb17a4557f34a02a4664f885d3bc329114b1b">kNERtcNoError</a>)：方法调用成功。</li>
<li>30001(<a class="el" href="namespacenertc.html#af062cfe332d58922ac8c020d55f9bb17ab0d4df087aca771f4fb9beae010d29a2">kNERtcErrFatal</a>)：通用错误。</li>
<li>30003(<a class="el" href="namespacenertc.html#af062cfe332d58922ac8c020d55f9bb17a59c84121b01e3bfb7997e8151651d8f3">kNERtcErrInvalidParam</a>)：参数错误。</li>
<li>30109(<a class="el" href="namespacenertc.html#af062cfe332d58922ac8c020d55f9bb17a01663267db14556ea392e0b31cf512b6">kNERtcErrSwitchChannelInvalidState</a>): 切换房间状态无效。</li>
<li>403(<a class="el" href="namespacenertc.html#af062cfe332d58922ac8c020d55f9bb17a8e357b832e04b84d230bfb43558f28d6">kNERtcErrChannelReservePermissionDenied</a>): 用户角色不是观众。</li>
<li>30100(<a class="el" href="namespacenertc.html#af062cfe332d58922ac8c020d55f9bb17ae0420e5316b4b57b5627cb0d259d6963">kNERtcErrChannelAlreadyJoined</a>): 房间名无效，已在此房间中。 </li>
</ul>
</dd></dl>
</li>
</ul>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>include/<a class="el" href="nertc__engine_8h_source.html">nertc_engine.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
